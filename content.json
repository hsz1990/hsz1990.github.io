{"meta":{"title":"Hexo","subtitle":"","description":"","author":"hsz199086@163.com","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2020-03-06T07:02:12.605Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Mail: hsz199086@163.comCity: Wuhan.ChinaOccupation: frontend-developer hia hia hia hia …"},{"title":"categories","date":"2020-03-06T04:53:19.000Z","updated":"2020-03-06T05:28:14.758Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-02T10:22:54.000Z","updated":"2020-03-06T06:26:50.156Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vuex基础","slug":"vuex基础","date":"2020-03-10T14:27:08.000Z","updated":"2020-03-13T16:43:44.947Z","comments":true,"path":"posts/33001/","link":"","permalink":"http://yoursite.com/posts/33001/","excerpt":"","text":"vuex基础1.基础使用 在项目的根目录下新增store文件夹，文件夹下创建index.js 12345678910import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)const store &#x3D; new Vuex(&#123; state: &#123; name: &#39;helloVueX&#39;, count: 1 &#125;&#125;)export default store 将store挂载到当前项目的Vue实例当中 123456789101112import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import router from &#39;.&#x2F;router&#39;import store from &#39;.&#x2F;store&#39;Vue.config.productionTip &#x3D; false&#x2F;* eslint-disable no-new *&#x2F;new Vue(&#123; el: &#39;#app&#39;, router, store, render: h &#x3D;&gt; h(App)&#125;) 获取store中的状态 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id&#x3D;&#39;app&#39;&gt; name: &lt;!--方式1: 模板中直接获取 --&gt; &lt;h1&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123; computed: &#123; &#x2F;&#x2F; 方式2: 计算属性映射 count () &#123; return store.state.count &#125;, &#x2F;&#x2F; 方式4: mapState 辅助函数加入计算属性 ...mapState(&#123; name: state &#x3D;&gt; state.name &#125;) &#125;, methods: &#123; test () &#123; &#x2F;&#x2F; 方式3: 方法中直接获取 console.log(this.$store.state.name) &#125; &#125;&#125;&lt;&#x2F;script&gt; 修改state状态为了方便调试及维护，不建议在组件中直接对state中的成员进行操作。一般使用mutations对state的数据修改、增加、删除等。12345678910111213141516171819&#x2F;&#x2F; src&#x2F;store&#x2F;index.js 增加mutations...const store &#x3D; new Vuex(&#123; state:&#123; ... &#125;, mutations:&#123; editName(state, payload)&#123; state.name &#x3D; payload &#125;, editPerson(state, payload)&#123; let &#123; age, sex, name &#125; &#x3D; payload state &#x3D; &#123; ...state, age, sex, name &#125; &#125; &#125;&#125;)export default store&#x2F;&#x2F; 组件中使用mutationsthis.$store.commit(&#39;editName&#39;, &#39;hello&#39;)&#x2F;&#x2F; 或者this.$store.commit(&#39;editPerson&#39;, &#123; name: &#39;hello&#39;, age: &#39;12&#39;, sex: &#39;m&#39; &#125;) 由于vuex不建议直接修改state，在处理表单时v-model等操作要特殊处理，如: &lt;input v-model=&quot;state.xxx&quot;&gt;12345678&#x2F;&#x2F; 使用带有 setter 的双向绑定计算属性computed: &#123; xxx: &#123; set (value) &#123; this.$store.commit(&#39;updateXXX&#39;, value) &#125; &#125;&#125; 2.vuex原理 vuex核心APIstate: 存储在 Vuex 中的数据和 Vue 实例中的 data 遵循相同的规则,对象必须是纯粹的对象 。mutations: 更改store中状态的唯一方法是提交 mutation。getters: 加工state成员给外界，返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。通过方法访问时，每次都会去进行调用，而不会缓存结果。 1234567891011&#x2F;&#x2F; src&#x2F;store&#x2F;index.js 增加getters...getters: &#123; getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123; return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id) &#125;&#125;&#x2F;&#x2F; 以属性的形式访问store.getters.getTodoById&#x2F;&#x2F; 通过方法访问不会缓存结果store.getters.getTodoById(2) actions: Action类似于mutation，但Action提交的是 mutation,可包含异步操作 1234567891011&#x2F;&#x2F; src&#x2F;store&#x2F;index.js 增加actions...actions: &#123; increment (context) &#123; setTimeout(() &#x3D;&gt; &#123; context.commit(&#39;increment&#39;) &#125;, 1000) &#125;&#125;&#x2F;&#x2F; 以属性的形式访问store.dispatch(&#39;increment&#39;) modules: Vuex 允许将store分割成模块 123456789101112131415161718192021&#x2F;&#x2F; src&#x2F;store&#x2F;index.js 增加modulesconst moduleA &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store &#x3D; new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)&#x2F;&#x2F; 获取modules的状态store.state.astore.state.b 运行原理 2.vuex插件Vuex 插件就是一个函数，它接收 store 作为唯一参数 123456789101112131415&#x2F;&#x2F; 一般以工厂函数创建插件export default function createMyPlugin (config) &#123; return (store) &#x3D;&gt; &#123; &#x2F;&#x2F; store 初始化后调用 store.subscribe((mutation, state) &#x3D;&gt; &#123; &#x2F;&#x2F; 每次提交mutation之后调用 let &#123; type, payload &#125; &#x3D;mutation console.log(type, payload) &#125;) &#125;&#125;&#x2F;&#x2F; src&#x2F;store&#x2F;index.js 增加pluginsconst store &#x3D; new Vuex.Store(&#123; plugins: [createMyPlugin(&#123;env: &#39;dev&#39;&#125;)]&#125;) 常用的vuex插件 vuex-persistedstate 刷新页面或关闭标签页时仍然保持state数据。 vuex-shared-mutations 在不同的标签页之间同步state数据。 4.模块及命名空间vuex使用单一状态树管理整个应用的状态，当应用变得非常复杂时，store 对象就有可能变得臃肿。为了解决这些问题，vuex提供模块化方式分割store。可以新建N个子文件夹，将上述提到的例子(src/store/index.js 增加modules)中每个模块都分离出来，无需赘述，但需注意几点： 对于模块内部的 mutation 和 getter，接收到的参数state是本模块的state，action中context.state也是(本模块)局部状态。全局state通过第三个参数或者context.rootState获取。 store 创建之后可以动态注册子模块12345678&#x2F;&#x2F; 注册模块 &#96;myModule&#96;store.registerModule(&#39;myModule&#39;, &#123; &#x2F;&#x2F; ...&#125;)&#x2F;&#x2F; 注册嵌套模块 &#96;nested&#x2F;myModule&#96;store.registerModule([&#39;nested&#39;, &#39;myModule&#39;], &#123; &#x2F;&#x2F; ...&#125;) commit或dispatch到全局添加第三个参数{ root: true },1234567891011 actions: &#123; &#x2F;&#x2F; 在这个模块中， dispatch 和 commit 也被局部化了 &#x2F;&#x2F; 他们可以接受 &#96;root&#96; 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someGetter&#39; rootGetters.someGetter &#x2F;&#x2F; -&gt; &#39;someGetter&#39; dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39; dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39; commit(&#39;someMutation&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someMutation&#39; commit(&#39;someMutation&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someMutation&#39;&#125; vuex默认没有开启命名空间，但开发时建议开启1234567const moduleA &#x3D; &#123; namespaced: true,&#x2F;&#x2F; 开启命名空间 state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125; 开启命名空间后: 避免commit或者dispatch时多个子module下同名mutation或者action同时响应(A和B都有mutationxxx，commit(‘xxx’),A和B都有数据变化)难以维护。 辅助函数需要指定命名空间字符串1234567891011方式1: 第一个参数指定mapActions(&#39;xxx&#x2F;moduleA&#39;, [&#39;helloXXX&#39;, &#39;workXXX&#39;]) mapXXXs(&#39;xxx&#x2F;moduleB&#39;,[...])方式2: 使用createNamespacedHelpers指定import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState &#125; &#x3D; createNamespacedHelpers(&#39;命名空间名&#39;)export default &#123; computed: &#123; ...mapState([&quot;permissionList&quot;]) &#125;&#125;","categories":[],"tags":[]},{"title":"uni-app实践-微信小程序转uniapp","slug":"uni-app实践与问题","date":"2020-03-09T04:50:04.000Z","updated":"2020-03-21T04:16:59.359Z","comments":true,"path":"posts/21963/","link":"","permalink":"http://yoursite.com/posts/21963/","excerpt":"","text":"uni-app实践-微信小程序转uniapp1.实现目标与效果在之前uniapp的学习过程中了解到uniapp的强大跨端兼容能力，那么能不能将之前的微信小程序或其他项目平滑的迁移到uniapp平台，从而是老项目具备跨端能力呢。本文记录一次微信小程序迁移到uniapp的过程。H5效果: 微信小程序效果: 支付宝小程序效果: PS:在我手动改了小部分代码后发现一个非常好用的自动转换工具miniprogram-to-uniapp，对于普通wxml转uniapp非常好用在此推荐。 2.转换步骤开发过小程序及vue项目的开发者基本会有一个感受，小程序与vue开发在很多时候都有相似，而uniapp完全兼容vue,同时开发规范靠近小程序开发。所以相对其他项目而言小程序老项目迁移到uniapp阻碍很小。 新建一个uniapp项目，修改app.vue,将app.js代码放入script, app.wxss放入style下，根据平台添加编译条件。 将app.json转换到pages.json，这里比较繁琐的是需要将每个页面下的json配置合并到pages.json。以首页为例，如下图index.json是pages下的配置文件： 在main.js中全局mixin一个setData方法(参考miniprogram-to-uniapp)。setData 是小程序开发中使用最频繁的接口,但uniapp中视图层和逻辑层的数据传输都是直接赋值。为了每个页面最少的代码修改，这里相当于做了一个hack。12345678910111213141516171819202122232425262728293031323334 &#x2F;&#x2F; main.jsimport Vue from &#39;vue&#39;;import App from &#39;.&#x2F;App&#39;;Vue.config.productionTip &#x3D; false;Vue.mixin(&#123; methods: &#123; setData: function(obj, callback) &#123; let that &#x3D; this; let keys &#x3D; []; let val, data; Object.keys(obj).forEach(function(key) &#123; keys &#x3D; key.split(&#39;.&#39;); val &#x3D; obj[key]; data &#x3D; that.$data; keys.forEach(function(key2, index) &#123; if (index + 1 &#x3D;&#x3D; keys.length) &#123; that.$set(data, key2, val); &#125; else &#123; if (!data[key2]) &#123; that.$set(data, key2, &#123;&#125;); &#125; &#125; data &#x3D; data[key2]; &#125;) &#125;); callback &amp;&amp; callback(); &#125; &#125;&#125;);App.mpType &#x3D; &#39;app&#39;;const app &#x3D; new Vue(&#123; ...App&#125;);app.$mount(); 每个页面下新建一个vue文件，将wxss的内容放入style，wxml的内容放入template&gt;view下，js中的Page传参稍作修改放入script。 对于步骤4中的script进行修改，主要包括: 将data改造为函数返回、将页面生命周期onXXX之外的其他方法放到methods下。 对于步骤4中的template进行修改,主要包括: attr=”“，改为 :attr=”a” title=”xxx“ 改为 :title=”‘xxx’ + item” bind:xxx=”methodXXX” 改@click=”methodXXX” catch:tap=”xx” 改为 @tap.native.stop=”xx” 对于mut-bind互斥事件，通过额外的flag进行条件处理 wx:if 改为 v-if、wx:for 改为v-for 对于pages.json中usingComponents引用的自定义组件可以自己按照步骤4到6类似的方式转换为.vue文件，也可以放入src/wxcomponents下，uniapp会自动在每个组件目录下生成.vue文件,注意需要将usingComponents的引用路径改下。 将所有静态文件放到static目录下，保持目录结构，然后在vue.config.js统一处理alias，避免在代码中修改引用路径。 以上这些步骤做完后就是进行跨端改造，一些平台独享的api或组件要特殊处理。 总体来说，老项目迁移到uniapp先看需要兼容的平台，将对应不兼容的API通过条件编译的方式屏蔽调，对于必须要的功能或者阻碍流程的代码使用新增hack的方式特殊平台特殊处理，尽可能少修改或不修改原来的代码。 3.注意事项 以上步骤如果每一个页面都执行一遍的话非常繁琐，其实很多步骤都是可以批量完成的，建议先用相关工具批量执行后再细致调整。相较于单纯的正则匹配替换，miniprogram-to-uniapp是通过babel进行词法分析，然后进行的修改，更加可靠，推荐使用。 当然工具不是万能的，比如miniprogram-to-uniapp无法将app.json和index.json合并后加入pages.json，无法区分代码平台添加条件编译，无法智能调整静态资源路径等等 一套代码多处运行非常考验代码的健壮性，一不小心可能会导致一行代码多处运行不畅，所以在uniapp中条件编译非常重要，测试时可根据目标平台边测试边修改，修改的代码比较复杂不能完全保证跨端运行时应添加编译条件以确保其他平台不被影响","categories":[],"tags":[]},{"title":"http学习笔记","slug":"http学习笔记","date":"2020-03-05T15:28:33.000Z","updated":"2020-03-06T05:21:53.649Z","comments":true,"path":"posts/17159/","link":"","permalink":"http://yoursite.com/posts/17159/","excerpt":"","text":"http学习笔记1.http协议 http是一个简单的纯文本、无状态的、面向连接的应用层协议，通常运行在TCP之上，目前http最新版本是2.0。 http协议请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。 http请求报文包括:请求行、请求头部、空行、请求数据。 http应答报文包括:状态行、响应头、空行、数据。 http协议运行在OSI七层概念模型中的应用层 应用层：负责解决业务问题 表示层：负责把网络中的消息转换成应用层可以读取的消息 会话层：负责建立会话、握手、维持连接、关闭 传输层：负责解决进程与进程之间的通信，例如TCP保证报文的可达性和流量的控制 网络层：负责解决广域网（Internet）中主机之间数据的传递网络层 数据链路层：负责局域网中根据MAC地址连接的相应的交换机/路由器进行报文的转发 物理层：物理传输介质 2.工作原理HTTP是基于客户/服务器模式，且面向连接的。典型场景是浏览器发起HTTP请求： 服务器监听80等web端口，浏览器从URL中解析出域名 浏览器根据域名查询DNS从而获取到对于的IP地址 通过查询到的IP地址与服务器建立TCP链接（如果是https协议还需要万TLS/SSL握手） 构造HTTP请求，在这个过程中填充上下文至HTTP头部 浏览器发送HTTP请求，服务器收到HTTP请求后将HTML页面作为包体返回给浏览器 浏览器引擎解析响应，渲染包体至用户界面，并根据超链接构造其他的HTTP请求 3.http的各种版本http发展至今经历了0.9/1.0/1.1/2.0四个版本，目前大部分网站使用的是http1.0/1.1协议，http2.0还在普及中。 0.9协议就是一个交换信息的无序协议，仅仅限于文字，1.0协议对每一次请求/响应建立并拆除一次连接，其特点是简单、易于管理，1.1在1.0基础上支持持久连接, 可以在同一个tcp的连接中可以传送多个HTTP请求和响应，2.0在1.0和1.1两个版本的基础上引入二进制数据帧和流的概念 在http协议的发展历程中还有两个重要的协议https和spdy 4.HTTPSHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版，不同于HTTP基于应用层,HTTPS基于传输层 HTTPS协议的主要功能基本都依赖于TLS/SSL协议 通过第三方机构CA和证书确保服务器身份的合法性 证书=公钥+申请者与颁发者信息+签名 CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。 HTTPS优势在于身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但代价是HTTPS协议的性能损耗，包括增加延时(握手过程)以及消耗较多的CPU资源(RSA解密等) 5.SPDY及HTTP2.0SPDY是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY是对HTTP协议的增强。特性： 单连接多路复用。在同一个域名下，SPDY只使用一个连接来加载一个页面的所有资源，在这个连接中可以打开多个流来同时传输数据 全双工，支持服务器推送。SPDY的流是双向的，允许服务器主动的同客户端建立流。SPDY通过Server Push和Server Hint技术，主动的向客户端推送资源，同时不发送已经缓存的资源 服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 server暗示（server hint）和server push不同的是，server hint并不会主动推送内容，只是告诉有新的内容产生，内容的下载还是需要客户端主动发起请求。一般应用场景是客户端需要先查询server状态，然后再下载资源，可以节约一次查询请求。 压缩HTTP头：SPDY通过zlib对HTTP头进行了压缩，并强制开启HTTP BODY的Gzip压缩 请求分级，重要的资源优先传送。SPDY通过建立0~7的优先级，使服务器会优先处理优先级高的请求 强制使用 SSL传输协议：SPDY为了安全强制使用安全协议，通过压缩和优先级策略来弥补安全协议的性能问题存在的问题 多域名请求下同样要建立多条连接 SSL/TLS协议的性能问题 所有头部名都需要小写 客户端必须支持 gzip 压缩 Google已经不再支持SPDY HTTP2.0是SPDY的升级，它采用了SPDY很多的特性和技术，但和SPDY还是有区别： HTTP2.0支持明文传输，SPDY强制使用SSL/TLS HTTP2.0采用HPACK算法压缩消息头 HTTP2.0对数据报文重新定义了二进制格式 HTTP2.0消息被分成很小的消息和帧,然后每个消息和帧用二进制编码。客户端和服务端都采用二进制编码和解码。 流：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。消息：一个完整的帧序列，它映射到逻辑的请求和响应消息。帧：在HTTP/2通信的最小单元。每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流。 所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。 每个流都有独一无二的标志和优先级。 每个消息都是逻辑上的请求和相应消息。由一个或者多个帧组成。 来自不同流的帧可以通过帧头的标志来关联和组装起来。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"spdy","slug":"spdy","permalink":"http://yoursite.com/tags/spdy/"}]},{"title":"koa基础学习笔记","slug":"koa基础学习笔记","date":"2020-03-03T07:34:59.000Z","updated":"2020-03-06T06:19:03.980Z","comments":true,"path":"posts/44367/","link":"","permalink":"http://yoursite.com/posts/44367/","excerpt":"","text":"koa基础学习笔记1.koa概况Koa 是一个简单好用的nodejs web框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码极简，所有功能都通过插件实现。koa1.x和koa2.x两个区别比较大，koa1.x使用generator控制项目同步，koa2.x使用ES7的async函数。大部分的中间件目前已经做了针对koa2.x的兼容。没有做兼容的中间件，可以使用 koa-convert中间件把generator转化一下。例: 123const convert &#x3D; require(&#39;koa-convert&#39;);const staticCache &#x3D; require(&#39;koa-static-cache&#39;);app.use(convert(staticCache(path.join(__dirname, &#39;public&#39;), &#123; maxAge: 365 * 24 * 60 * 60 &#125;))); 基本用法 12345678910const Koa &#x3D; require(&#39;koa&#39;);const app &#x3D; new Koa();app.use((ctx, next) &#x3D;&gt; &#123; console.log(&#96;$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;&#96;); next();&#125;);app.use(async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#39;Hello World&#39;;&#125;);app.listen(3000); 2.中间件Koa所有功能都使用中间件（middleware）来实现。每个中间件默认接受两个参数，第一个参数是Context对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件。多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。 123456789101112131415161718const one &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; one&#39;); next(); console.log(&#39;&lt;&lt; one&#39;);&#125;const two &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; two&#39;); next(); console.log(&#39;&lt;&lt; two&#39;);&#125;const three &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; three&#39;); next(); console.log(&#39;&lt;&lt; three&#39;);&#125;app.use(one);app.use(two);app.use(three); 如果中间件内部没有调用next函数，那么执行权就不会传递下去。注释two后异步中间件与同步中间件混合使用时，注意next之后的代码执行顺序 123456789101112131415161718192021222324252627282930313233const Koa &#x3D; require(&#39;koa&#39;);const app &#x3D; new Koa();const logger &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#96;$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;&#96;); next();&#125;const one &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; one&#39;); next(); console.log(&#39;&lt;&lt; one&#39;);&#125;const two &#x3D; async (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; two&#39;); await next(); console.log(&#39;&lt;&lt; two&#39;);&#125;const three &#x3D; (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; three&#39;); next(); console.log(&#39;&lt;&lt; three&#39;);&#125;const four &#x3D; async (ctx, next) &#x3D;&gt; &#123; console.log(&#39;&gt;&gt; four&#39;); await next(); console.log(&#39;&lt;&lt; four&#39;); ctx.body &#x3D; &#39;tets.......&#39;&#125;app.use(logger);app.use(one);app.use(two);app.use(three);app.use(four);app.listen(3000); 3.重要的对象及函数 nextnext函数主要负责将控制权交给下一个中间件，如果当前中间件没有终结请求，并且next没有被调用，那么当前中间件的请求将被挂起，等到next()后的中间件执行完再返回继续执行。 ctx.resNode 的 response 对象。Koa不支持直接调用底层res进行响应处理，避免使用res.statusCode、res.writeHead()、res.write()、res.end() response.body=String: Content-Type默认为text/html或者text/plain，两种默认charset均为utf-8。 Content-Length 同时会被设置。Buffer: Content-Type默认为application/octet-stream，Content-Length同时被设置。Stream: Content-Type默认为application/octet-stream。Object: Content-Type默认为application/json。这包括普通对象{ foo: ‘bar’ }和数组[‘foo’, ‘bar’]。当stream被设置为响应体时，.onerror将作为监听器自动添加到错误事件中以捕获任何错误。此外，每当请求被关闭（甚至更早）时，stream都将被销毁。如果不想要这两个功能，请不要直接将stream设置为响应体。如果res.status没有赋值，Koa会自动设置为200或204。 app.listen 1234server.listen(handle[, backlog][, callback])server.listen(options[, callback])server.listen(path[, backlog][, callback]) 用于 IPC 服务器。server.listen([port[, host[, backlog]]][, callback]) 用于 TCP 服务器。 这个函数是异步的。当服务器开始监听时，会触发 ‘listening’ 事件。 最后一个参数 callback 将被添加为 ‘listening’ 事件的监听器。所有的 listen() 方法都可以使用一个 backlog 参数来指定待连接队列的最大长度。 实际的长度将由操作系统的 sysctl 设置决定。此参数的默认值是 511当且仅当上次调用 server.listen() 发生错误或已经调用 server.close() 时，才能再次调用 server.listen() 方法。path是IPC连接的识别路径( http://nodejs.cn/api/net.html#net_identifying_paths_for_ipc_connections ) 4.常用中间件 表单处理 1234567const koaBody &#x3D; require(&#39;koa-body&#39;);const main &#x3D; async function(ctx) &#123; const body &#x3D; ctx.request.body; if (!body.name) ctx.throw(400, &#39;.name required&#39;); ctx.body &#x3D; &#123; name: body.name &#125;;&#125;;app.use(koaBody()); 文件上传 123456789101112131415161718const os &#x3D; require(&#39;os&#39;);const path &#x3D; require(&#39;path&#39;);const koaBody &#x3D; require(&#39;koa-body&#39;);const main &#x3D; async function(ctx) &#123; const tmpdir &#x3D; os.tmpdir(); const filePaths &#x3D; []; const files &#x3D; ctx.request.body.files || &#123;&#125;; for (let key in files) &#123; const file &#x3D; files[key]; const filePath &#x3D; path.join(tmpdir, file.name); const reader &#x3D; fs.createReadStream(file.path); const writer &#x3D; fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); &#125; ctx.body &#x3D; filePaths;&#125;;app.use(koaBody(&#123; multipart: true &#125;)); 路由 1234567891011121314 var route &#x3D; require(&#39;koa-route&#39;);&#x2F;&#x2F;引入中间件之后支持的写法差不多，只是路径传入route，然后把route作为中间件挂载到appapp.use(route.get(&#39;&#x2F;&#39;, list));app.use(route.get(&#39;&#x2F;post&#x2F;new&#39;, add));app.use(route.get(&#39;&#x2F;post&#x2F;:id&#39;, show));app.use(route.post(&#39;&#x2F;post&#39;, create));&#x2F;&#x2F;链式写法var router &#x3D; require(&#39;koa-router&#39;)();router.get(&#39;&#x2F;&#39;, list) .get(&#39;&#x2F;post&#x2F;new&#39;, add) .get(&#39;&#x2F;post&#x2F;:id&#39;, show) .post(&#39;&#x2F;post&#39;, create);app.use(router.routes()) .use(router.allowedMethods()); 网页模板 12345678910111213var views &#x3D; require(&#39;co-views&#39;);var render &#x3D; views(&#39;tpls&#39;, &#123; map: &#123; html: &#39;swig&#39; &#125;,&#x2F;&#x2F;html后缀使用引擎 default: &quot;jade&quot;&#x2F;&#x2F;render不提供后缀名时&#125;);var userInfo &#x3D; &#123; name: &#39;tobi&#39;, species: &#39;ferret&#39;&#125;;var html;html &#x3D; render(&#39;user&#39;, &#123; user: userInfo &#125;);html &#x3D; render(&#39;user.jade&#39;, &#123; user: userInfo &#125;);html &#x3D; render(&#39;user.ejs&#39;, &#123; user: userInfo &#125;); 5.错误处理1234567891011121314151617181920212223242526272829const Koa &#x3D; require(&#39;koa&#39;);const app &#x3D; new Koa();&#x2F;&#x2F; 错误处理中间件, 洋葱最外层app.use(async (ctx, next)&#x3D;&gt;&#123; try &#123; await next(); &#125; catch (error) &#123; &#x2F;&#x2F; 响应用户 ctx.status &#x3D; error.statusCode || error.status || 500; ctx.body &#x3D; error.message; ctx.app.emit(&#39;error&#39;, error); &#x2F;&#x2F; 触发应用层级错误事件 &#125;&#125;);app.use(async (ctx, next)&#x3D;&gt;&#123; console.log(&quot;前置操作&quot;); await next(); console.log(&quot;后置操作&quot;);&#125;);app.use(ctx&#x3D;&gt;&#123; &#x2F;&#x2F; 抛出错误, 也可以理解为模拟错误发生 throw new Error(&quot;未知错误&quot;); console.log(&quot;执行任务...&quot;);&#125;);&#x2F;&#x2F; 全局错误事件监听app.on(&#39;error&#39;, (error)&#x3D;&gt;&#123; console.error(error);&#125;);&#x2F;&#x2F; 语法糖, 等同于http.createServer(app.callback()).listen(3000);app.listen(3000);","categories":[],"tags":[{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"nodejs web","slug":"nodejs-web","permalink":"http://yoursite.com/tags/nodejs-web/"}]},{"title":"uni-app组件学习笔记","slug":"uni-app组件学习笔记","date":"2020-02-28T10:16:04.000Z","updated":"2020-03-13T16:33:14.474Z","comments":true,"path":"posts/63461/","link":"","permalink":"http://yoursite.com/posts/63461/","excerpt":"","text":"uni-app中的各种组件通过之前uni-app基础学习了解到uni-app是一个海纳百川的框架，它支持各种各样的组件及编码方式。虽然官网推荐使用插件市场的uni-app原生插件代替微信小程序等其他规范的组件，但更多的时候我们都有自己工作中积累的自定义组件，所以如何平滑的迁移到目标平台也是我们关注的一个重点。开始前的准备: 通过CLI创建项目vue create -p dcloudio/uni-preset-vue my-test 选择默认模板新建一个空项目 以H5方式运行项目 12cd my-testnpm run serve (由于写文时条件限制我的电脑是linux系统，没有安装微信/支付宝等开发者工具，以下运行效果图皆只有H5平台，后续补充) 1. uni-app组件uni-app组件大致分为内置组件、官方扩展组件、第三方uni-app插件，几乎所有组件都有各自自定义的属性，可以对该组件的功能或样式进行修饰 uni-app内置组件是最常用的，与微信内置组件相同。基础组件分为以下八大类（以下列出部分组件的注意点）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;table&gt; &lt;tr&gt; &lt;th&gt;类别&lt;&#x2F;th&gt; &lt;th&gt;组件&lt;&#x2F;th&gt; &lt;th&gt;描述及注意事项&lt;&#x2F;th&gt; &lt;&#x2F;tr &gt; &lt;tr &gt; &lt;td rowspan&#x3D;&quot;3&quot;&gt;视图容器&lt;&#x2F;td&gt; &lt;td&gt;view&lt;&#x2F;td&gt; &lt;td&gt;视图容器，类似于HTML中的div&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;scroll-view&lt;&#x2F;td&gt; &lt;td&gt; 1.scroll-view 不适合放长列表，有性能问题。长列表滚动和下拉刷新，应该使用原生导航栏搭配页面级的滚动和下拉刷新实现。&lt;br&#x2F;&gt; 2.scroll-view是区域滚动，不会触发页面滚动，无法触发pages.json配置的下拉刷新、页面触底onReachBottomDistance、titleNView的transparent透明渐变。 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;swiper&lt;&#x2F;td&gt; &lt;td&gt; 1.swiper是单页组件，适合做banner图轮播和简单列表左右滑动。&lt;br&#x2F;&gt; 2.因为性能问题，swiper不适合做复杂的长列表。 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td rowspan&#x3D;&quot;4&quot;&gt;基础内容组件&lt;&#x2F;td&gt; &lt;td&gt;icon&lt;&#x2F;td&gt; &lt;td&gt;图标&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;text&lt;&#x2F;td&gt; &lt;td&gt; 1.组件内只支持嵌套text组件，不支持其它组件或自定义组件，否则会引发在不同平台的渲染差异。 2.支持 \\n 方式换行。 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;rich-text&lt;&#x2F;td&gt; &lt;td&gt;富文本,支付宝小程序 nodes 属性只支持使用 Array 类型&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;progress&lt;&#x2F;td&gt; &lt;td&gt;进度条&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td rowspan&#x3D;&quot;2&quot;&gt;表单组件&lt;&#x2F;td&gt; &lt;td&gt;picker&lt;&#x2F;td&gt; &lt;td&gt;弹出式列表选择器&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;picker-view&lt;&#x2F;td&gt; &lt;td&gt;窗体内嵌式列表选择器&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;导航&lt;&#x2F;td&gt; &lt;td &gt;navigator&lt;&#x2F;td&gt; &lt;td&gt;页面链接。类似于HTML中的a标签&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td rowspan&#x3D;&quot;3&quot; &gt;媒体组件&lt;&#x2F;td&gt; &lt;td &gt;audio&lt;&#x2F;td&gt; &lt;td&gt;不再维护，使用uni.createInnerAudioContext 替代&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;live-player&lt;&#x2F;td&gt; &lt;td&gt;直播播放&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;live-pusher&lt;&#x2F;td&gt; &lt;td&gt;实时音视频录制，也称直播推流&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;媒体组件&lt;&#x2F;td&gt; &lt;td &gt;audio&lt;&#x2F;td&gt; &lt;td&gt;不再维护，使用uni.createInnerAudioContext 替代&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;地图&lt;&#x2F;td&gt; &lt;td &gt;map&lt;&#x2F;td&gt; &lt;td&gt; 组件的宽&#x2F;高推荐写直接量，比如：750rpx，不要设置百分比值。&lt;br&#x2F;&gt; uni-app 只支持 gcj02 坐标 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;画布&lt;&#x2F;td&gt; &lt;td &gt;canvas&lt;&#x2F;td&gt; &lt;td&gt; 1.默认宽度300px、高度 225px，大小后需要重新绘制&lt;br&#x2F;&gt; 2.同一页面中的 canvas-id 不可重复,否则画布将被隐藏&lt;br&#x2F;&gt; 3.微信、百度、QQ小程序中层级高于前端组件,不可内嵌在 scroll-view、swiper、picker-view、movable-view 中使用 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td &gt;webview&lt;&#x2F;td&gt; &lt;td &gt;web-view&lt;&#x2F;td&gt; &lt;td&gt; 1.小程序仅支持加载网络网页，不支持本地html&lt;br&#x2F;&gt; 2.小程序端 web-view 组件一定有原生导航栏，下面一定是全屏的 web-view 组件，navigationStyle: custom 对 web-view 组件无效。 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; uni-app扩展组件(即uni-ui)是DCloud提供的一个跨端ui库，它是基于vue组件的、flex布局的、无dom的跨全端ui框架,它是基础组件的补充。 如果创建项目时没有选择hello uni-app模板，则可使用npm引入uni-ui npm install @dcloudio/uni-ui uni-ui目前小程序和混合app领域，暂时还没有比uni ui更高性能的框架。在满足业务条件的情况下不要使用自定义组件。 注:uni-ui 不支持使用 Vue.use() 的方式安装 uni-app第三方插件市场及本地自定义组件是对以上两种组件的补充 2. vue组件uni-app只支持vue单文件组件,所以在使用第三方组件如：npm引入某组件的时候应注意。有些原生vue支持的组件在uni-app中是错误的组件,例如： 123456789101112131415161718192021222324&#x2F;&#x2F; uni-app不支持的组件&#x2F;&#x2F; 1.动态组件&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;&#x2F;&#x2F; 2.异步组件Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#123; template: &#39;&lt;div&gt;I am async!&lt;&#x2F;div&gt;&#39; &#125;) &#125;, 1000)&#125;)&#x2F;&#x2F; 3.包含自定义render的组件&lt;script&gt; ... export default &#123; data() &#123; return &#123; &#125; &#125;, ... render (createElement) &#123; return createElement(...) &#125; &#125;&lt;&#x2F;script&gt; 组件的引用兼容了vue及小程序使用方式1：在src目录下创建/component目录存放组件，以插件市场中的uni-goods-nav为例: 插件市场中下载组件包(https://ext.dcloud.net.cn/plugin?id=865) 解压后将goods-nav目录放置在component目录下 引入插件、注册、使用，与常规vue开发一模一样 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;view&gt; &lt;view class&#x3D;&quot;goods-carts&quot;&gt; &lt;uni-goods-nav :options&#x3D;&quot;options&quot; :button-group&#x3D;&quot;buttonGroup&quot; &#x2F;&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; import uniGoodsNav from &#39;@&#x2F;components&#x2F;uni-goods-nav&#x2F;uni-goods-nav.vue&#39; export default &#123; components: &#123; uniGoodsNav &#125;, data() &#123; return &#123; options: [&#123; icon: &#39;https:&#x2F;&#x2F;img-cdn-qiniu.dcloud.net.cn&#x2F;uniapp&#x2F;uni-ui&#x2F;goodsnav&#x2F;kefu.png&#39;, text: &#39;客服&#39; &#125;, &#123; icon: &#39;https:&#x2F;&#x2F;img-cdn-qiniu.dcloud.net.cn&#x2F;uniapp&#x2F;uni-ui&#x2F;goodsnav&#x2F;dianpu.png&#39;, text: &#39;店铺&#39; &#125;, &#123; icon: &#39;https:&#x2F;&#x2F;img-cdn-qiniu.dcloud.net.cn&#x2F;uniapp&#x2F;uni-ui&#x2F;goodsnav&#x2F;carts.png&#39;, text: &#39;购物车&#39;, info: 2 &#125;], buttonGroup: [&#123; text: &#39;加入购物车&#39;, backgroundColor: &#39;#ffa200 &#39;, color: &#39;#fff&#39; &#125;, &#123; text: &#39;立即购买&#39;, backgroundColor: &#39;#ff0000&#39;, color: &#39;#fff&#39; &#125; ] &#125; &#125; &#125;&lt;&#x2F;script&gt; 使用方式2： 与方式1一样，但使用组件时与小程序一样在pages.json中引入组件 12345678&#123; &quot;path&quot;: &quot;subPages&#x2F;demo&#x2F;uni-goods-nav&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;购物车&quot;, &quot;usingComponents&quot;: &#123; &quot;uni-goods-nav&quot;: &quot;&#x2F;components&#x2F;uni-goods-nav&#x2F;uni-goods-nav&quot; &#125;&#125; 得到的效果:熟悉web开发的前端开发者都习惯从npm仓库中获取组件，所以很多时候觉得通过下载组件包然后解压的方式显得很怪异，实际上uni-app是支持npm方式引入组件的，只是这有很大风险会有部分平台不支持的问题。可以通过条件编译来屏蔽不支持的平台。以mpvue-echarts为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;&#x2F; npm安装包npm install echarts mpvue-echarts --save&#x2F;&#x2F; echarts-weixin.vue&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;mpvue-echarts :echarts&#x3D;&quot;echarts&quot; :onInit&#x3D;&quot;onInit&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import * as echarts from &#39;echarts&#39; import mpvueEcharts from &#39;mpvue-echarts&#39; export default &#123; components: &#123; mpvueEcharts &#125;, data() &#123; return &#123; echarts, onInit: function (canvas, width, height) &#123; ... &#125; &#125; &#125; &#125; &lt;&#x2F;script&gt;&#x2F;&#x2F; echarts-h5.vue&lt;script&gt;import * as echarts from &#39;echarts&#39;var myChart &#x3D; echarts.init(document.getElementById(&#39;echarts&#39;));myChart.setOption(&#123; ...&#125;)&lt;&#x2F;script&gt;&#x2F;&#x2F; pages.json#ifdef MP-WEIXIN&#123; &quot;path&quot;: &quot;pages&#x2F;demo&#x2F;echarts-weixin&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;demo-echarts&quot; &#125;&#125;,#endif#ifdef H5&#123; &quot;path&quot;: &quot;pages&#x2F;demo&#x2F;echarts-h5&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;demo-echarts&quot; &#125;&#125;,#endif 3. 微信小程序组件由于性能问题，开发中应尽量避免直接使用小程序的组件。但是uni-app仍然 支持在App 和 小程序 中使用小程序自定义组件。 在项目src目录下新建小程序组件放置目录，微信及QQ-wxcomponents/支付宝-mycomponents/百度-swancomponents/头条-ttcomponents 在 pages.json 对应页面的 style -&gt; usingComponents 引入组件 页面中使用组件 以有赞的vant-weapp button组件为例 下载组件并放置到wxcomponents目录下: npm i @vant/weapp -S --production 复制node_modules/@vant/weapp/dist/button到wxcomponents/vant/下 pages.json 中使用组件 123456&#123; &quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;&#x2F;wxcomponents&#x2F;vant&#x2F;button&#x2F;index&quot; &#125;, &quot;navigationBarTitleText&quot;: &quot;test-vant&quot;&#125; demo-test-wx.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;view&gt; &lt;view class&#x3D;&quot;uni-common-mt&quot; style&#x3D;&quot;text-align: center;&quot;&gt; &lt;van-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onClick&quot;&gt;vant按钮组件&lt;&#x2F;van-button&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; checked: true &#125;; &#125;, methods: &#123; onClick() &#123; uni.showToast(&#123; title: &quot;uni-app支持在微信小程序、QQ小程序端、App端、H5端引入微信小程序自定义组件。&quot;, mask: false, icon: &quot;none&quot;, duration: 3000 &#125;); &#125; &#125; &#125;&lt;&#x2F;script&gt; 效果：","categories":[],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"http://yoursite.com/tags/uni-app/"},{"name":"vuejs","slug":"vuejs","permalink":"http://yoursite.com/tags/vuejs/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"跨多端","slug":"跨多端","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%A4%9A%E7%AB%AF/"}]},{"title":"uni-app基础学习笔记","slug":"uni-app基础学习笔记","date":"2020-02-26T05:04:15.000Z","updated":"2020-03-06T05:26:41.402Z","comments":true,"path":"posts/55711/","link":"","permalink":"http://yoursite.com/posts/55711/","excerpt":"","text":"uni-app基础学习笔记1. uni-app介绍uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，一套代码可编译到iOS、Android、H5、小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台（可以通过条件编译区分各平台特殊代码）。uni-app完整支持vue生命周期和模板语法，如果会vue基本上就可以解决大多数问题了，学习成本非常低。(暂时绕开了原生APP开发相关如nvue，h5+等内容)官方演示用例(https://github.com/dcloudio/hello-uniapp )可快速体验和学习框架的常用组件和案例 2. uni-app编码统一规范 页面组件遵循Vue 单文件组件 (SFC) 规范 组件标签靠近微信小程序规范 接口能力（JS API）靠近微信小程序规范 数据绑定及事件处理靠近 Vue.js 规范，同时补充了App及页面的生命周期 为兼容多端运行，建议使用flex布局进行开发 3. 创建uni-app项目注意事项 可通过HBuilderX可视化界面、vue-cli命令行两种方式快速创建项目。 官方推出的 HBuilderX 编辑器，内置相关环境，开箱即用 uni-app在发布到H5时支持所有vue的语法 cli版如果想安装less、scss、ts等编译器，需自己手动npm安装。在HBuilderX的插件管理界面安装无效，那个只作用于HBuilderX创建的项目。 HBuilderX云打包可以使用Dcloud公用开发者证书进行测试，或者使用自己的开发者证书。 4. 项目迁移注意事项(1) H5项目迁移至uni-app 后缀名是.html，需要改为.vue，并注意遵循vue单文件组件SFC规范 uni-app默认是小程序的路由方式(pages.json管理页面)，如果使用vue-rooter的话可以使 用uni-simple-router等第三方插件做兼容 静态文件挪到static目录（静态资源只能存放于此） 使用scroll-view、swiper等原生组件替换H5组件 audio组件使用uni.getBackgroundAudioManager()替换 v-html使用rich-text组件或uparse扩展插件替换 uni-app非H5端不支持window、navigator、document等web专用对象，使用条件编译区 分 不支持 *选择器及部分新的css (2) 微信小程序转换uni-app指南及转换器：https://ask.dcloud.net.cn/article/357865. 关于uni-app生命周期uni-app 完整支持 Vue 实例的生命周期，此外新增应用生命周期及页面生命周期。 应用生命周期 onLaunch初始化完成时触发（全局只触发一次） onShow启动或从后台进入前台显示时触发 onHide从前台进入后台时触发 onError报错时触发 onUniNViewMessage监听nvue页面发送的数据 注:应用生命周期仅可在App.vue中监听，在其它页面监听无效。在onlaunch生命周期内进行页面的跳转可能会和pages.json内配置的第一个页面跳转冲突,造成白屏，需要进行延时跳转。 页面生命周期（部分常用） onLoad监听页面加载，参数类型为Object，类似微信小程序 onShow监听页面显示，包括从下级页面返回当前页面 onReady监听页面初次渲染完成，如果渲染速度快，会在页面进入动画完成前触发 onPullDownRefresh监听用户下拉动作，一般用于下拉刷新 onReachBottom页面上拉触底事件的处理函数 onShareAppMessage用户点击右上角分享(小程序) onBackPress监听页面返回(https://ask.dcloud.net.cn/article/35120) 关于.nvue页面(即Native vue)：uni-app App端内置 weex 渲染引擎，提供了原生渲染能力，但是weex提供的api不完整,nuve相当于给weex补充了大量组件和api，以及丰富的Plus API、Native.js、原生插件。(详情: https://ask.dcloud.net.cn/article/36074) 6. 关于uni-app组件注意事项 非H5端需要注意Slot不支持scoped，不支持动态组件、异步组件、inline-template、X-Templates、keep-alive、transition uni-app 内置了小程序的所有组件，但原生组件上的事件绑定需要以vue语法来写(bindchange=”xxx”等改成@change=”xxx”) uni-app组件有命名限制，组件名最好有特殊前缀或后缀(参考: https://uniapp.dcloud.io/use?id=%e5%91%bd%e5%90%8d%e9%99%90%e5%88%b6 ) uni-app内置了vuex uni-app支持小程序自定义组件(wxcomponents目录下)，但是小程序组件的性能不如vue组件，不建议使用,另外小程序自定义组件只能在pages.json中配置 usingComponents,不支持页面引用。(参考: https://ask.dcloud.net.cn/article/35786 ) 7. 条件编译 用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。uni-app支持ifdef和ifndef(除了xx平台)，多个平台用||连接。例:123#ifdef H5||APP-PLUS需条件编译的代码#endif 如果想把各平台的页面文件更彻底的分开，也可以在uni-app项目根目录创建platforms目录，然后在下面创建APP-PLUS、MP-WEIXIN等子目录，存放不同平台的文件。 静态资源按不同平台区分的可在static目录下新建平台目录(注意使用小写，如：mp-weixin等) 8. 部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法） 各家小程序的浏览器内核不同，会造成css兼容性问题(参考：https://ask.dcloud.net.cn/article/1318 ) 各家小程序存在不一样的支持度(如：支付宝小程序不支持ECharts，百度小程序不支持v-if和for同时使用)，遇到相关问题可关注是否有相应版本更新或使用条件编译来不同平台不同处理。 微信小程序端的原生组件存在层级问题，可以用cover-view、cover-image来进行覆盖 uni-app中可以使用upx作为自适应单位，但不支持动态绑定，可以使用uni.upx2px转化为px。 关于Class 与 Style 绑定，非H5端支持简单的样式绑定，绑定的值只能是字符串，不支持复杂的绑定，比如:class=”[class-a,class-b]” 9. 使用总结 uni-app官方文档( https://uniapp.dcloud.io/README )非常详细，对于初学和使用uni-app非常有帮助 因基本完整支持vue的语法及特性,uni-app的学习成本很低 对于跨端uni-app最好是以小程序的编码方式为主向其他端扩展，参考以上第3条H5项目迁移至uni-app 开发工具官方推荐HBuilderX，对于惯用Sublime/Atom等编辑器的开发者可以平滑过渡，其他开发者使用vue-cli的方式也很方便，但是仍然需要HbuilderX打包到安卓/IOS(无需打包原生APP的忽略) 目前uni-app插件市场( https://ext.dcloud.net.cn/ )有1K+第三方插件，但是质量良莠不齐只能筛选后使用和参考 uni-app支持使用npm安装第三方包，但是为多端兼容考虑应优先从uni-app插件市场获取插件，直接从npm下载库很容易只兼容H5端，当然也可使用条件编译将该部分特殊处理 总体来说uni-app是一个非常好的跨平台开发框架，框架本身的文档也非常详细，但是目前开放生态并不是很完善，很多第三方插件文档也很模糊，如果单纯只开发某一个平台的代码可以绕开uni-app，但是如果是跨端需求则非常适合用uni-app，因为使用条件编译进行各平台的独有代码开发也没有增加工作量。uni-app在跨端抹平度、扩展灵活性、性能体验、学习成本、开发成本等方面都非常优秀(官方说的8个指标虽有广告成分但也确实很优秀)。","categories":[],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"http://yoursite.com/tags/uni-app/"},{"name":"vuejs","slug":"vuejs","permalink":"http://yoursite.com/tags/vuejs/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"跨多端","slug":"跨多端","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%A4%9A%E7%AB%AF/"}]}]}