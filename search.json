[{"title":"nodejs流梳理","url":"/posts/65411/","content":"\n## nodejs流梳理\n前段时间实现一个nodejs 的反向代理时遇到一个问题，需要将一个远程获取的图片返回给浏览器端，并同时缓存到本地。由于不了解nodejs流，使用了fs.readFile导致文件比较大请求频繁时内存占用严重。  \n对于前端开发人员来说nodejs中stream API夹杂了许多新名词或新概念阻碍我们对它的理解，本文梳理了一下nodejs流中的一些概念。   \n\n#### 1.什么是流\n官方定义流是 Node.js 中处理流式数据的抽象接口。  \n那么什么是流式数据？数组或者字符串等普通类型的数据是一个内存中所存的数据，获取这个内存中的数据就是完整的数据集合，但是流式数据可能不是完整的存在内存中，它不需要一次装载所有数据，只需要一小片内存，不断的循环利用这片内存装载指定的那个数据集合。正因为这样，使得流可以处理超大容量的数据。  \n\n在 Node.js很多内置模块都实现了流接口，而stream 模块主要用于创建新类型的流实例。\n```\nconst { Readable } = require('stream');\nclass MyReadable extends Readable {\n    constructor(options) {\n        // 调用 stream.Readable(options) 构造函数。\n        super(options);\n        // ...\n    }\n    // 自定义可读流必须实现readable._read() 方法\n    _read() { ... }\n}\n```\n\n\n#### 2.流的类型\nnodejs的流基本分为四种:\n+ 可读流(Readable)是数据可以被消费的源的抽象，例如fs.createReadStream  \n+ 可写流(Writable)是数据可以被写入目标的抽象，例如 fs.createWriteStream  \n+ 双向流(Duplex)是可读也可写的流，例如 TCP socket。\n+ 转换流(Transform)是基于双向流的，可以在读或者写的时候被用来更改或者转换数据。例如 zlib.createGzip使用gzip 算法压缩数据。\n\n此外，nodejs中流分为两种模式:\n+ 二进制模式, 每个分块都是buffer或者string对象\n+ 对象模式, 流内部处理的是一系列普通对象.(writable.write(chunk[,encoding][, callback])中的chunk不再是字符串、 Buffer 或 Uint8Array；readable.read([size])的返回值不再是Buffer而是普通javascript对象)\n\n当创建流时，可以使用 objectMode 选项把流实例切换到对象模式。 将已存在的流切换到对象模式是不安全的。\n\n#### 2.内部缓冲区大小(highWaterMark)\n可写流和可读流都会在内部的缓冲器中存储数据(writable.writableBuffer/ readable.readableBuffer)。可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。 二进制流模式highWaterMark 指定了字节的总数，对象模式highWaterMark指定了对象的总数。\n\n可读流对象在实现readable._read()接口时需调用stream.push(chunk)，将数据缓冲在可读流中。 如果流的消费者没有调用 stream.read()，则数据会保留在内部队列中直到被消费。  \n![可读流原理图](/images/node-stream-event-readable.png)\n一旦内部的可读缓冲的总大小达到 highWaterMark 指定的阈值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费 (也就是说，流会停止调用readable._read())。  \n\n当调用 writable.write(chunk) 时，数据会被缓冲在可写流中。 当内部的可写缓冲的总大小小于 highWaterMark 设置的阈值时，调用 writable.write() 会返回 true。 一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回 false。\n\n#### 3.可读流(stream.Readable)\n可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。 这些模式与对象模式分开(无论处于流动模式或暂停模式，都可以处于对象模式)。\n\n流动模式下监听data事件进行chunk块处理，无需调用read\n暂停模式下需要循环调用read方法，直到读取完成\n```\n// 流动模式\nfs.createReadableStream('./dome.txt')\n     .on('data', function(chunk) {\n       console.log(chunk.toString());\n     })\n// 暂停模式\nlet rds = fs.createReadableStream('./dome.txt')\n   rds.on('readable', function() {\n        var chunk;\n        while((chunk = rds.read()) !== null) {\n            console.log(chunk.toString());\n        }\n    })\n```\n\n所有可读流都默认是暂停模式，以下几种情况下转换为流动模式。\n+ 添加了data事件监听\n+ 调用stream.resume()\n+ 调用stream.pipe()\n\n可读流切换回暂停模式会有一些注意点：\n+ 添加'readable'事件句柄会使流自动停止流动\n+ 如果没有管道目标，调用 stream.pause()\n+ 移除 'data' 事件句柄不会自动地暂停流\n+ 如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。\n\ndrain状态:这里涉及一个概念, 背压(back-pressure), 就是当生产者速度大于消费者的时候, 输出流(可写流)的水位会不断上升, 当到达highWaterMark, 就会写入失败, 这时候也就是产生了背压, 停止写入数据，当可以继续写入数据时(即drain状态)会触发drain事件, 监听这个事件,可以继续向流写入数据.\n\n只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。  \n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时没有监听 'data' 事件。\n\n#### 4.可写流(stream.Writable)\n可写流的具体实例可能略有差别，但所有的可写流都遵循同一基本的使用模式\n```\nconst myStream = getWritableStreamSomehow();\nmyStream.write('一些数据');\nmyStream.write('更多数据');\nmyStream.end('完成写入数据');\n```\n在可写流上有两个事件比较有趣，pipe(添加管道事件)和unpipe(移除管道事件)，一般的我们在哪个对象上调用方法就会触发那个对象上的事件相应的也是在那个对象上监听事件，但这里在可读流上调用 stream.pipe() 方法时会触发目标流(可写流) 的'pipe' 事件（unpipe同理）。另外调用pipe/unpipe方法返回可读流本身可继续链式调用pipe/unpipe方法。\n\n#### 5.双向流(stream.Duplex)\n双向流就是把输入流和输出流的接口都实现了.  \n此时option参数是同时传给了内部的Readable和Writeable, 如果要使用不同的选项, 就要分开配置,例如:\n```\nthis._writableState.objectMode\nthis._readableState.objectMode\n```\n双向流多了一个选项allowHalfOpen, 意思是当其中一个流关闭的时候, 另外一条流是否也同时关闭, 默认是true, 也就是不同时关闭.\n\n#### 6.转换流(stream.Transform)\n转换流实现了_transform() 和 _flush()接口.  \n转换流一般在transform的过程中把读写都做了, 也就是在处理输入的时候, 直接就输出了. 最后在输入结束的时候_flush() 会被调用, 就可以把剩余的内部数据一并输出了.\n```\n// 解决的问题是在流中操作替换操作,其中替换的部分可以仔细看一下, stream和buffer一个很大的区别就是stream会被切割,导致要替换的数据也有可能被切割, 这个例子就提供了一种解决方法, 这个在后续实践中肯定也会遇到的.\nimport { Transform } from 'stream';\nclass ReplaceStream extends Transform {\n\tconstruct (option) {\n    \tsuper( { ...option, decodeStrings: false })\n    \tlet { searchString,  replaceString } = option\n        this.searchString = searchString || ''\n        this.replaceString = replaceString || ''\n        this.tailPiece = ''\n    }\n    _transform (chunk, encoding, callback) {\n        var pieces = (this.tailPiece + chunk).split(this.searchString);\n        var lastPiece = pieces[pieces.length - 1];\n        var tailPieceLen = this.searchString.length - 1;\n        this.tailPiece = lastPiece.slice(-tailPieceLen);\n        pieces[pieces.length - 1] = lastPiece.slice(0, -tailPieceLen);\n        this.push(pieces.join(this.replaceString)); \n        callback();\n    }\n    _flush (callback) {\n        this.push(this.tailPiece);\n        callback();\n    }\n}\nexport default ReplaceStream\n```\n\n#### 7.npm资源\n虽然nodejs中关于流的API比较多比较复杂，但能够帮助我们很好的理解流。实际开发中一些优秀的npm包能够帮我们快速使用nodejs流。  \n[through2](https://www.npmjs.com/package/through2) 快速创建转化流  \n[from2](https://www.npmjs.com/package/from2) 快速创建输入流  \n[writable2](https://www.npmjs.com/package/writable2) 快速创建输出流\n"},{"title":"vue-router进阶文档学习笔记","url":"/posts/45803/","content":"\n## vue-router进阶文档学习笔记\n#### 1.概述及原理\n随着前端业务越来越复杂，以及用户体验要求提升，原本多页面应用的开发模式越发难以满足要求，单页面应用更加受到追捧，而单页面应用更新页面视图需要统一管理(即前端路由)。\n![单页面与多页面应用对比](/images/2020-03-22-20-30-57.png)  \n更新视图但不能重新请求页面是前端路由核心，主要通过两种方式实现:  \n&emsp;&emsp;一是通过改变以及解析URL中的hash(即'#'后面的部分)；  \n&emsp;&emsp;二是通过操作History State(HTML5新增，IE9以上浏览器支持)  \nvue-router是Vue.js框架的路由插件，它和 Vue.js 的核心深度集成。  vue-router除了实现了上述两种方式外还支持abstract模式，该模式支持全部的javascript运行环境，如nodejs。我们看下vue-router关于模式选择的源码:\n![vue-router关于模式选择](/images/2020-03-22-23-35-11.png)\nabstract模式的实现也很简单，stack数组保存route链，index指定当前route，源码如下:\n![abstract模式源码](/images/2020-03-23-00-43-38.png)  \n基础使用:\n```\n//声明式导航\n<!-- 配置path: /user/:userId  导航URL: /user/123  -->\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\n<!-- /user?userId=123  -->\n<router-link :to=\"{ path: 'user', query: { userId: '123' }}\" >User</router-link>\n//编程式导航\nrouter.push({ name: 'user', params: { userId: 123 }})\n```\n\n#### 2.导航守卫\n![完整的导航解析流程](../images/2020-03-25-23-16-48.png)\n导航守卫基本分为三类\n+ 全局守卫: router.beforeEach(全局前置守卫)、router.beforeResolve(全局解析守卫)、router.afterEach(全局后置钩子)\n   ```\n   const router = new VueRouter({ ... })\n   /**\n    * to: Route: 即将要进入的目标 路由对象\n\t* from: Route: 当前导航正要离开的路由\n\t* next: Function: 一定要调用该方法来 resolve 这个钩子。\n    */\n    router.beforeEach((to, from, next) => {\n    \t// next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。\n        // next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n        // next('/xxx') 或者 next({ path: '/xxx' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。\n        // next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。\n   })\n   router.beforeResolve((to, from, next) => {\n       // 和beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。\n    })\n\trouter.afterEach((to, from) => {\n      // 和其他全局守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身\n    })\n   ```\n+ 路由独享守卫: 在路由配置上直接定义 beforeEnter 守卫\n+ 组件内守卫: 在组件内定义路由的导航守卫beforeRouteEnter 、beforeRouteUpdate 、beforeRouteLeave\n```\n// beforeRouteEnter 是支持给 next 传递回调的唯一守卫\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n// 对于beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。\nbeforeRouteUpdate (to, from, next) {\n  // 可以使用this\n  this.name = to.params.name\n  next() // 不支持callback\n}\n// 离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。\nbeforeRouteLeave (to, from, next) {\nconst answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n  if (answer) {\n    next()\n  } else {\n    next(false)\n  }\n}\n```\n\n参数或查询的改变并不会触发进入/离开的导航守卫。可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。\n\n#### 3.滚动行为\nvue-router可以自定义路由切换时页面如何滚动，但这个功能只在IE9+浏览器(支持history.pushState)中可用。\n```\nconst router = new VueRouter({\n  routes: [...],\n  /**\n  * 注意1: 挂载点时router实例，而不是路由记录(routers下)\n  * 注意2: savePosition只有在通过浏览器的 前进/后退 按钮触发的跳转才有值\n  */\n  scrollBehavior (to, from, savedPosition) {\n      if (savedPosition) {\n        // 当且仅当popstate导航有效\n        return savedPosition\n      } else {\n        const position = {}\n        // return的位置对象添加selector属性以滚动到锚点\n        if (to.hash) {\n          position.selector = to.hash\n          // 滚动到#anchor2再滚 { y: 100 }\n          if (to.hash === '#anchor2') {\n            position.offset = { y: 100 }\n          }\n          // return一个空对象或falsy值(undefind/null等)则没有滚动行为\n          return false\n        }\n        // return一个Promise以实现异步滚动\n        return new Promise(resolve => {\n          // 通过路由元信息判断是否滚动到顶部\n          if (to.matched.some(m => m.meta.scrollToTop)) {\n            // 当selector属性无效时x,y位置信息才生效\n            position.x = 0\n            position.y = 0\n          }\n          // 等待外层的动画或其他行为完成后(触发自定义事件xxx)滚动\n          this.app.$root.$once('xxx', () => {\n            resolve(position)\n          })\n  }\n})\n```\n"},{"title":"vuex基础","url":"/posts/33001/","content":"## vuex基础\n#### 1.基础使用\n1. 在项目的根目录下新增store文件夹，文件夹下创建index.js  \n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\nconst store = new Vuex({\n    state: {\n        name: 'helloVueX',\n        count: 1\n    }\n})\nexport default store\n```\n2. 将store挂载到当前项目的Vue实例当中  \n```\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './store'\nVue.config.productionTip = false\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  store,  \n  render: h => h(App)\n})\n```\n3. 获取store中的状态  \n```\n<template>\n    <div id='app'>\n        name:\n        <!--方式1: 模板中直接获取 -->\n        <h1>{{ $store.state.name }}</h1>\n    </div>\n</template>\n<script>\nimport { mapState } from 'vuex'\nexport default {\n\tcomputed: {\n    \t // 方式2: 计算属性映射\n         count () {\n\t      return store.state.count\n\t     },\n    \t// 方式4: mapState 辅助函数加入计算属性\n         ...mapState({\n    \t\tname: state => state.name\n         })\n    },\n\tmethods: {\n    \ttest () {\n            // 方式3: 方法中直接获取\n        \tconsole.log(this.$store.state.name)\n        }\n    }\n}\n</script>\n```\n4. 修改state状态  \n为了方便调试及维护，不建议在组件中直接对state中的成员进行操作。一般使用mutations对state的数据修改、增加、删除等。\n```\n// src/store/index.js 增加mutations\n...\nconst store = new Vuex({\n    state:{ ... },\n    mutations:{\n        editName(state, payload){\n            state.name = payload\n        },\n        editPerson(state, payload){\n            let { age, sex, name } = payload\n            state = { ...state, age, sex, name }\n        }\n    }\n})\nexport default store\n// 组件中使用mutations\nthis.$store.commit('editName', 'hello')\n// 或者\nthis.$store.commit('editPerson', { name: 'hello', age: '12', sex: 'm' })\n```\n由于vuex不建议直接修改state，在处理表单时v-model等操作要特殊处理，如: `<input v-model=\"state.xxx\">`\n```\n// 使用带有 setter 的双向绑定计算属性\ncomputed: {\n  xxx: {\n    set (value) {\n      this.$store.commit('updateXXX', value)\n    }\n  }\n}\n```\n\n#### 2.vuex原理\n1. vuex核心API  \nstate: 存储在 Vuex 中的数据和 Vue 实例中的 data 遵循相同的规则,对象必须是纯粹的对象 。  \nmutations: 更改store中状态的唯一方法是提交 mutation。\ngetters: 加工state成员给外界，返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。通过方法访问时，每次都会去进行调用，而不会缓存结果。  \n```\n// src/store/index.js 增加getters\n...\ngetters: {\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n// 以属性的形式访问\nstore.getters.getTodoById\n// 通过方法访问不会缓存结果\nstore.getters.getTodoById(2)\n```\nactions: Action类似于mutation，但Action提交的是 mutation,可包含异步操作  \n```\n// src/store/index.js 增加actions\n...\nactions: {\n    increment (context) {\n       setTimeout(() => {\n      \t\tcontext.commit('increment')\n    \t}, 1000)\n    }\n}\n// 以属性的形式访问\nstore.dispatch('increment')\n```\nmodules: Vuex 允许将store分割成模块  \n```\n// src/store/index.js 增加modules\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n// 获取modules的状态\nstore.state.a\nstore.state.b\n```\n2. 运行原理\n![Vuex运行原理](/images/16550832-20d0ad3c60a99111.webp)\n\n#### 2.vuex插件\nVuex 插件就是一个函数，它接收 store 作为唯一参数\n```\n// 一般以工厂函数创建插件\nexport default function createMyPlugin (config) {\n\treturn (store) => {\n        // store 初始化后调用\n        store.subscribe((mutation, state) => {\n            // 每次提交mutation之后调用\n            let { type, payload } =mutation\n            console.log(type, payload)\n        })\n\t}\n}\n// src/store/index.js 增加plugins\nconst store = new Vuex.Store({\n  plugins: [createMyPlugin({env: 'dev'})]\n})\n```\n常用的vuex插件\n1. [vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate) 刷新页面或关闭标签页时仍然保持state数据。\n2. [vuex-shared-mutations](https://github.com/xanf/vuex-shared-mutations) 在不同的标签页之间同步state数据。\n\n#### 4.模块及命名空间\nvuex使用单一状态树管理整个应用的状态，当应用变得非常复杂时，store 对象就有可能变得臃肿。为了解决这些问题，vuex提供模块化方式分割store。可以新建N个子文件夹，将上述提到的例子(src/store/index.js 增加modules)中每个模块都分离出来，无需赘述，但需注意几点：\n   + 对于模块内部的 mutation 和 getter，接收到的参数state是本模块的state，action中context.state也是(本模块)局部状态。全局state通过第三个参数或者context.rootState获取。\n   +  store 创建之后可以动态注册子模块\n   ```\n   // 注册模块 `myModule`\n   store.registerModule('myModule', {\n     // ...\n   })\n   // 注册嵌套模块 `nested/myModule`\n   store.registerModule(['nested', 'myModule'], {\n     // ...\n   })\n   ```\n   + commit或dispatch到全局添加第三个参数{ root: true },\n   ```\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n   }\n   ```\n   + vuex默认没有开启命名空间，但开发时建议开启\n   ```\n   const moduleA = {\n      namespaced: true,// 开启命名空间\n      state: { ... },\n      mutations: { ... },\n      actions: { ... },\n      getters: { ... }\n    }\n   ```\n   开启命名空间后:\n      + 避免commit或者dispatch时多个子module下同名mutation或者action同时响应(A和B都有mutationxxx，commit('xxx'),A和B都有数据变化)难以维护。\n      + 辅助函数需要指定命名空间字符串\n      ```\n\t\t方式1: 第一个参数指定\n\t\tmapActions('xxx/moduleA', ['helloXXX', 'workXXX']) \n\t\tmapXXXs('xxx/moduleB',[...])\n\t\t方式2: 使用createNamespacedHelpers指定\n\t\timport { createNamespacedHelpers } from \"vuex\";\n\t\tconst { mapState } = createNamespacedHelpers('命名空间名')\n\t\texport default {\n\t\t\tcomputed: {\n\t\t\t\t...mapState([\"permissionList\"])\n\t\t\t}\n\t\t}\n      ```"},{"title":"uni-app实践-微信小程序转uniapp","url":"/posts/21963/","content":"## uni-app实践-微信小程序转uniapp\n#### 1.实现目标与效果\n在之前uniapp的学习过程中了解到uniapp的强大跨端兼容能力，那么能不能将之前的微信小程序或其他项目平滑的迁移到uniapp平台，从而是老项目具备跨端能力呢。本文记录一次微信小程序迁移到uniapp的过程。  \nH5效果:  \n![H5运行效果](/images/2020-03-20-15-37-42.png)  \n\n微信小程序效果:  \n![微信小程序效果](/images/2020-03-20-19-49-32.png)  \n\n支付宝小程序效果:\n![支付宝小程序效果](/images/2020-03-21-11-42-27.png)\n\nPS:在我手动改了小部分代码后发现一个非常好用的自动转换工具[miniprogram-to-uniapp](https://github.com/zhangdaren/miniprogram-to-uniapp)，对于普通wxml转uniapp非常好用在此推荐。\n\n#### 2.转换步骤\n开发过小程序及vue项目的开发者基本会有一个感受，小程序与vue开发在很多时候都有相似，而uniapp完全兼容vue,同时开发规范靠近小程序开发。所以相对其他项目而言小程序老项目迁移到uniapp阻碍很小。\n   1. 新建一个uniapp项目，修改app.vue,将app.js代码放入script, app.wxss放入style下，根据平台添加编译条件。\n   ![app.vue](/images/2020-03-20-17-30-34.png)\n   2. 将app.json转换到pages.json，这里比较繁琐的是需要将每个页面下的json配置合并到pages.json。以首页为例，如下图index.json是pages下的配置文件：\n   ![合并文件对比](/images/2020-03-20-22-31-42.png)\n   3. 在main.js中全局mixin一个setData方法(参考miniprogram-to-uniapp)。setData 是小程序开发中使用最频繁的接口,但uniapp中视图层和逻辑层的数据传输都是直接赋值。为了每个页面最少的代码修改，这里相当于做了一个hack。\n   ```\n   // main.js\nimport Vue from 'vue';\nimport App from './App';\nVue.config.productionTip = false;\nVue.mixin({\n\tmethods: {\n\t\tsetData: function(obj, callback) {\n\t\t\tlet that = this;\n\t\t\tlet keys = [];\n\t\t\tlet val, data;\n\t\t\tObject.keys(obj).forEach(function(key) {\n\t\t\t\tkeys = key.split('.');\n\t\t\t\tval = obj[key];\n\t\t\t\tdata = that.$data;\n\t\t\t\tkeys.forEach(function(key2, index) {\n\t\t\t\t\tif (index + 1 == keys.length) {\n\t\t\t\t\t\tthat.$set(data, key2, val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!data[key2]) {\n\t\t\t\t\t\t\tthat.$set(data, key2, {});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata = data[key2];\n\t\t\t\t})\n\t\t\t});\n\t\t\tcallback && callback();\n\t\t} \n\t}\n});\nApp.mpType = 'app';\nconst app = new Vue({\n    ...App\n});\napp.$mount();\n   ```\n   4. 每个页面下新建一个vue文件，将wxss的内容放入style，wxml的内容放入template>view下，js中的Page传参稍作修改放入script。\n   5. 对于步骤4中的script进行修改，主要包括: 将data改造为函数返回、将页面生命周期onXXX之外的其他方法放到methods下。\n   6. 对于步骤4中的template进行修改,主要包括:\n      + attr=\"{{ a }}\"，改为 :attr=\"a\"\n      + title=\"xxx{{ item }}\" 改为 :title=\"'xxx' + item\"\n      + bind:xxx=\"methodXXX\" 改@click=\"methodXXX\"\n      + catch:tap=\"xx\" 改为 @tap.native.stop=\"xx\"\n      + 对于mut-bind互斥事件，通过额外的flag进行条件处理\n      + wx:if 改为 v-if、wx:for 改为v-for\n   7. 对于pages.json中usingComponents引用的自定义组件可以自己按照步骤4到6类似的方式转换为.vue文件，也可以放入src/wxcomponents下，uniapp会自动在每个组件目录下生成.vue文件,注意需要将usingComponents的引用路径改下。\n   8. 将所有静态文件放到static目录下，保持目录结构，然后在vue.config.js统一处理alias，避免在代码中修改引用路径。\n   9. 以上这些步骤做完后就是进行跨端改造，一些平台独享的api或组件要特殊处理。\n\n总体来说，老项目迁移到uniapp先看需要兼容的平台，将对应不兼容的API通过条件编译的方式屏蔽调，对于必须要的功能或者阻碍流程的代码使用新增hack的方式特殊平台特殊处理，尽可能少修改或不修改原来的代码。\n\n#### 3.注意事项\n1. 以上步骤如果每一个页面都执行一遍的话非常繁琐，其实很多步骤都是可以批量完成的，建议先用相关工具批量执行后再细致调整。相较于单纯的正则匹配替换，miniprogram-to-uniapp是通过babel进行词法分析，然后进行的修改，更加可靠，推荐使用。\n2. 当然工具不是万能的，比如miniprogram-to-uniapp无法将app.json和index.json合并后加入pages.json，无法区分代码平台添加条件编译，无法智能调整静态资源路径等等\n3. 一套代码多处运行非常考验代码的健壮性，一不小心可能会导致一行代码多处运行不畅，所以在uniapp中条件编译非常重要，测试时可根据目标平台边测试边修改，修改的代码比较复杂不能完全保证跨端运行时应添加编译条件以确保其他平台不被影响\n"},{"title":"http学习笔记","url":"/posts/17159/","content":"##  http学习笔记\n#### 1.http协议  \n+ http是一个简单的纯文本、无状态的、面向连接的应用层协议，通常运行在TCP之上，目前http最新版本是2.0。  \n+ http协议请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。  \n+ http请求报文包括:请求行、请求头部、空行、请求数据。  \n![请求报文结构](/images/http-01.jpg)  \n+ http应答报文包括:状态行、响应头、空行、数据。\n![响应报文结构](/images/http-02.png)  \n+ http协议运行在OSI七层概念模型中的应用层  \n![OSI七层概念模型](/images/http-04.png)\n   - 应用层：负责解决业务问题  \n   - 表示层：负责把网络中的消息转换成应用层可以读取的消息  \n   - 会话层：负责建立会话、握手、维持连接、关闭  \n   - 传输层：负责解决进程与进程之间的通信，例如TCP保证报文的可达性和流量的控制  \n   - 网络层：负责解决广域网（Internet）中主机之间数据的传递\n网络层  \n   - 数据链路层：负责局域网中根据MAC地址连接的相应的交换机/路由器进行报文的转发  \n   - 物理层：物理传输介质  \n\n#### 2.工作原理\nHTTP是基于客户/服务器模式，且面向连接的。典型场景是浏览器发起HTTP请求：  \n   1. 服务器监听80等web端口，浏览器从URL中解析出域名  \n   2. 浏览器根据域名查询DNS从而获取到对于的IP地址  \n   3. 通过查询到的IP地址与服务器建立TCP链接（如果是https协议还需要万TLS/SSL握手）  \n   4. 构造HTTP请求，在这个过程中填充上下文至HTTP头部  \n   5. 浏览器发送HTTP请求，服务器收到HTTP请求后将HTML页面作为包体返回给浏览器  \n   6. 浏览器引擎解析响应，渲染包体至用户界面，并根据超链接构造其他的HTTP请求  \n![浏览器发起HTTP请求背后](/images/http-03.png)  \n\n#### 3.http的各种版本\nhttp发展至今经历了0.9/1.0/1.1/2.0四个版本，目前大部分网站使用的是http1.0/1.1协议，http2.0还在普及中。\n   + 0.9协议就是一个交换信息的无序协议，仅仅限于文字，1.0协议对每一次请求/响应建立并拆除一次连接，其特点是简单、易于管理，1.1在1.0基础上支持持久连接, 可以在同一个tcp的连接中可以传送多个HTTP请求和响应，2.0在1.0和1.1两个版本的基础上引入二进制数据帧和流的概念\n   + 在http协议的发展历程中还有两个重要的协议https和spdy\n\n#### 4.HTTPS\nHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版，不同于HTTP基于应用层,HTTPS基于传输层  \n   + HTTPS协议的主要功能基本都依赖于TLS/SSL协议  \n   ![TLS/SSL协议](/images/http-05.png)\n   + 通过第三方机构CA和证书确保服务器身份的合法性\n    ![TLS/SSL协议](/images/http-06.png)  \n       - 证书=公钥+申请者与颁发者信息+签名\n       - CA负责审核信息，然后对关键信息利用私钥进行\"签名\"，公开对应的公钥，客户端可以利用公钥验证签名。\n   + HTTPS优势在于身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但代价是HTTPS协议的性能损耗，包括增加延时(握手过程)以及消耗较多的CPU资源(RSA解密等)\n\n#### 5.SPDY及HTTP2.0\nSPDY是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY是对HTTP协议的增强。特性：\n   + 单连接多路复用。在同一个域名下，SPDY只使用一个连接来加载一个页面的所有资源，在这个连接中可以打开多个流来同时传输数据\n   + 全双工，支持服务器推送。SPDY的流是双向的，允许服务器主动的同客户端建立流。SPDY通过Server Push和Server Hint技术，主动的向客户端推送资源，同时不发送已经缓存的资源\n      - 服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。\n      - server暗示（server hint）和server push不同的是，server hint并不会主动推送内容，只是告诉有新的内容产生，内容的下载还是需要客户端主动发起请求。一般应用场景是客户端需要先查询server状态，然后再下载资源，可以节约一次查询请求。\n   +  压缩HTTP头：SPDY通过zlib对HTTP头进行了压缩，并强制开启HTTP BODY的Gzip压缩\n   +  请求分级，重要的资源优先传送。SPDY通过建立0~7的优先级，使服务器会优先处理优先级高的请求\n   +  强制使用 SSL传输协议：SPDY为了安全强制使用安全协议，通过压缩和优先级策略来弥补安全协议的性能问题\n存在的问题\n   + 多域名请求下同样要建立多条连接\n   + SSL/TLS协议的性能问题\n   + 所有头部名都需要小写\n   + 客户端必须支持 gzip 压缩\n   + Google已经不再支持SPDY\n\nHTTP2.0是SPDY的升级，它采用了SPDY很多的特性和技术，但和SPDY还是有区别：\n   + HTTP2.0支持明文传输，SPDY强制使用SSL/TLS\n   + HTTP2.0采用HPACK算法压缩消息头\n   + HTTP2.0对数据报文重新定义了二进制格式  \n\nHTTP2.0消息被分成很小的消息和帧,然后每个消息和帧用二进制编码。客户端和服务端都采用二进制编码和解码。\n>流：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。  \n>消息：一个完整的帧序列，它映射到逻辑的请求和响应消息。  \n>帧：在HTTP/2通信的最小单元。每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流。  \n \n   - 所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。\n   - 每个流都有独一无二的标志和优先级。\n   - 每个消息都是逻辑上的请求和相应消息。由一个或者多个帧组成。\n   - 来自不同流的帧可以通过帧头的标志来关联和组装起来。\n\n\n","tags":["http","https","spdy"]},{"title":"koa基础学习笔记","url":"/posts/44367/","content":"\n## koa基础学习笔记  \n\n#### 1.koa概况\nKoa 是一个简单好用的nodejs web框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码极简，所有功能都通过插件实现。  \nkoa1.x和koa2.x两个区别比较大，koa1.x使用generator控制项目同步，koa2.x使用ES7的async函数。大部分的中间件目前已经做了针对koa2.x的兼容。没有做兼容的中间件，可以使用 koa-convert中间件把generator转化一下。例: \n\n```\nconst convert = require('koa-convert');\nconst staticCache = require('koa-static-cache');\napp.use(convert(staticCache(path.join(__dirname, 'public'), { maxAge: 365 * 24 * 60 * 60 })));\n```\n\n基本用法 \n\n```\nconst Koa = require('koa');\nconst app = new Koa();\napp.use((ctx, next) => {\n\tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n\tnext();\n});\napp.use(async ctx => {\n  ctx.body = 'Hello World';\n});\napp.listen(3000);\n```\n\n#### 2.中间件\nKoa所有功能都使用中间件（middleware）来实现。每个中间件默认接受两个参数，第一个参数是Context对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件。多个中间件会形成一个栈结构（middle stack），以\"先进后出\"（first-in-last-out）的顺序执行。  \n![中间件的洋葱结构](/images/72150-0e1846c8c7bdf999.webp)  \n\n```\nconst one = (ctx, next) => {\n\tconsole.log('>> one');\n\tnext();\n\tconsole.log('<< one');\n}\nconst two = (ctx, next) => {\n\tconsole.log('>> two');\n\tnext(); \n\tconsole.log('<< two');\n}\nconst three = (ctx, next) => {\n\tconsole.log('>> three');\n\tnext();\n\tconsole.log('<< three');\n}\napp.use(one);\napp.use(two);\napp.use(three);\n```\n\n如果中间件内部没有调用next函数，那么执行权就不会传递下去。  \n![运行效果](/images/2020-03-03-18-44-49.png)  \n注释two后  \n![运行效果](/images/2020-03-03-18-44-27.png)  \n异步中间件与同步中间件混合使用时，注意next之后的代码执行顺序\n\n```\nconst Koa = require('koa');\nconst app = new Koa();\nconst logger = (ctx, next) => {\n\tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n\tnext();\n}\nconst one = (ctx, next) => {\n\tconsole.log('>> one');\n\tnext();\n\tconsole.log('<< one');\n}\nconst two = async (ctx, next) => {\n\tconsole.log('>> two');\n\tawait next(); \n\tconsole.log('<< two');\n}\nconst three = (ctx, next) => {\n\tconsole.log('>> three');\n\tnext();\n\tconsole.log('<< three');\n}\nconst four = async (ctx, next) => {\n\tconsole.log('>> four');\n\tawait next();\n\tconsole.log('<< four');\n\tctx.body = 'tets.......'\n}\napp.use(logger);\napp.use(one);\napp.use(two);\napp.use(three);\napp.use(four);\napp.listen(3000);\n```\n\n![运行效果](/images/2020-03-04-13-07-20.png)\n\n#### 3.重要的对象及函数\n+ next  \nnext函数主要负责将控制权交给下一个中间件，如果当前中间件没有终结请求，并且next没有被调用，那么当前中间件的请求将被挂起，等到next()后的中间件执行完再返回继续执行。  \n+ ctx.res  \nNode 的 response 对象。  \nKoa不支持直接调用底层res进行响应处理，避免使用res.statusCode、res.writeHead()、res.write()、res.end()    \n+ response.body=  \nString: Content-Type默认为text/html或者text/plain，两种默认charset均为utf-8。 Content-Length 同时会被设置。  \nBuffer: Content-Type默认为application/octet-stream，Content-Length同时被设置。  \nStream: Content-Type默认为application/octet-stream。  \nObject: Content-Type默认为application/json。这包括普通对象{ foo: 'bar' }和数组['foo', 'bar']。  \n当stream被设置为响应体时，.onerror将作为监听器自动添加到错误事件中以捕获任何错误。此外，每当请求被关闭（甚至更早）时，stream都将被销毁。如果不想要这两个功能，请不要直接将stream设置为响应体。  \n如果res.status没有赋值，Koa会自动设置为200或204。  \n+ app.listen  \n\n```\nserver.listen(handle[, backlog][, callback])\nserver.listen(options[, callback])\nserver.listen(path[, backlog][, callback]) 用于 IPC 服务器。\nserver.listen([port[, host[, backlog]]][, callback]) 用于 TCP 服务器。\n```\n\n这个函数是异步的。当服务器开始监听时，会触发 'listening' 事件。 最后一个参数 callback 将被添加为 'listening' 事件的监听器。  \n所有的 listen() 方法都可以使用一个 backlog 参数来指定待连接队列的最大长度。 实际的长度将由操作系统的 sysctl 设置决定。此参数的默认值是 511  \n当且仅当上次调用 server.listen() 发生错误或已经调用 server.close() 时，才能再次调用 server.listen() 方法。  \npath是IPC连接的识别路径( http://nodejs.cn/api/net.html#net_identifying_paths_for_ipc_connections )  \n\n#### 4.常用中间件\n\n+ 表单处理\n\n```\n\tconst koaBody = require('koa-body');\n\tconst main = async function(ctx) {\n\t\tconst body = ctx.request.body;\n\t\tif (!body.name) ctx.throw(400, '.name required');\n\t\tctx.body = { name: body.name };\n\t};\n\tapp.use(koaBody());\n```\n\n+ 文件上传\n\n```\n\tconst os = require('os');\n\tconst path = require('path');\n\tconst koaBody = require('koa-body');\n\tconst main = async function(ctx) {\n\t\tconst tmpdir = os.tmpdir();\n\t\tconst filePaths = [];\n\t\tconst files = ctx.request.body.files || {};\n\t\tfor (let key in files) {\n\t    \tconst file = files[key];\n\t    \tconst filePath = path.join(tmpdir, file.name);\n\t    \tconst reader = fs.createReadStream(file.path);\n\t    \tconst writer = fs.createWriteStream(filePath);\n\t    \treader.pipe(writer);\n\t    \tfilePaths.push(filePath);\n\t  \t}\n  \t\tctx.body = filePaths;\n\t};\n\tapp.use(koaBody({ multipart: true }));\n```\n\n+ 路由\n\n```\n   \tvar route = require('koa-route');\n\t//引入中间件之后支持的写法差不多，只是路径传入route，然后把route作为中间件挂载到app\n\tapp.use(route.get('/', list));\n\tapp.use(route.get('/post/new', add));\n\tapp.use(route.get('/post/:id', show));\n\tapp.use(route.post('/post', create));\n\t//链式写法\n\tvar router = require('koa-router')();\n\trouter.get('/', list)\n\t    .get('/post/new', add)\n\t    .get('/post/:id', show)\n\t    .post('/post', create);\n\tapp.use(router.routes())\n\t   .use(router.allowedMethods());\n```\n\n+ 网页模板\n\n```\n\tvar views = require('co-views');\n\tvar render = views('tpls', {\n\t    map: { html: 'swig' },//html后缀使用引擎\n\t    default: \"jade\"//render不提供后缀名时\n\t});\n\tvar userInfo = {\n\t    name: 'tobi',\n\t    species: 'ferret'\n\t};\n\tvar html;\n\thtml = render('user', { user: userInfo });\n\thtml = render('user.jade', { user: userInfo });\n\thtml = render('user.ejs', { user: userInfo });\n```\n\n#### 5.错误处理\n\n```\nconst Koa = require('koa');\nconst app = new Koa();\n// 错误处理中间件, 洋葱最外层\napp.use(async (ctx, next)=>{\n    try {\n        await next();\n    } catch (error) {\n        // 响应用户\n        ctx.status = error.statusCode || error.status || 500;\n        ctx.body = error.message;\n        ctx.app.emit('error', error); // 触发应用层级错误事件\n    }\n});\napp.use(async (ctx, next)=>{\n    console.log(\"前置操作\");\n    await next();\n    console.log(\"后置操作\");\n});\napp.use(ctx=>{\n    // 抛出错误, 也可以理解为模拟错误发生\n    throw new Error(\"未知错误\");\n    console.log(\"执行任务...\");\n});\n// 全局错误事件监听\napp.on('error', (error)=>{\n    console.error(error);\n});\n// 语法糖, 等同于http.createServer(app.callback()).listen(3000);\napp.listen(3000);\n```\n","tags":["koa","nodejs web"]},{"title":"uni-app组件学习笔记","url":"/posts/63461/","content":"## uni-app中的各种组件  \n通过之前uni-app基础学习了解到uni-app是一个海纳百川的框架，它支持各种各样的组件及编码方式。虽然官网推荐使用插件市场的uni-app原生插件代替微信小程序等其他规范的组件，但更多的时候我们都有自己工作中积累的自定义组件，所以如何平滑的迁移到目标平台也是我们关注的一个重点。  \n开始前的准备:  \n+ 通过CLI创建项目  \n`vue create -p dcloudio/uni-preset-vue my-test`\n+ 选择默认模板新建一个空项目  \n![选择模板](/images/h5-cli-01.png)  \n+ 以H5方式运行项目  \n```\ncd my-test\nnpm run serve\n```\n(由于写文时条件限制我的电脑是linux系统，没有安装微信/支付宝等开发者工具，以下运行效果图皆只有H5平台，后续补充)\n\n#### 1. uni-app组件\nuni-app组件大致分为内置组件、官方扩展组件、第三方uni-app插件，几乎所有组件都有各自自定义的属性，可以对该组件的功能或样式进行修饰\n+ uni-app内置组件是最常用的，与微信内置组件相同。基础组件分为以下八大类（以下列出部分组件的注意点）：\n\n```\n<table>\n    <tr>\n        <th>类别</th>\n        <th>组件</th>\n        <th>描述及注意事项</th>\n    </tr >\n    <tr >\n        <td rowspan=\"3\">视图容器</td>\n        <td>view</td>\n        <td>视图容器，类似于HTML中的div</td>\n    </tr>\n    <tr>\n        <td>scroll-view</td>\n        <td>\n            1.scroll-view 不适合放长列表，有性能问题。长列表滚动和下拉刷新，应该使用原生导航栏搭配页面级的滚动和下拉刷新实现。<br/>\n            2.scroll-view是区域滚动，不会触发页面滚动，无法触发pages.json配置的下拉刷新、页面触底onReachBottomDistance、titleNView的transparent透明渐变。\n        </td>\n    </tr>\n    <tr>\n        <td>swiper</td>\n        <td>\n                1.swiper是单页组件，适合做banner图轮播和简单列表左右滑动。<br/>\n                2.因为性能问题，swiper不适合做复杂的长列表。\n        </td>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">基础内容组件</td>\n        <td>icon</td>\n        <td>图标</td>\n    </tr>\n    <tr>\n        <td>text</td>\n        <td>\n            1.组件内只支持嵌套text组件，不支持其它组件或自定义组件，否则会引发在不同平台的渲染差异。\n            2.支持 \\n 方式换行。\n        </td>\n    </tr>\n    <tr>\n        <td>rich-text</td>\n        <td>富文本,支付宝小程序 nodes 属性只支持使用 Array 类型</td>\n    </tr>\n    <tr>\n        <td>progress</td>\n        <td>进度条</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">表单组件</td>\n        <td>picker</td>\n        <td>弹出式列表选择器</td>\n    </tr>\n    <tr>\n        <td>picker-view</td>\n        <td>窗体内嵌式列表选择器</td>\n    </tr>\n    <tr>\n        <td >导航</td>\n        <td >navigator</td>\n        <td>页面链接。类似于HTML中的a标签</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\" >媒体组件</td>\n        <td >audio</td>\n        <td>不再维护，使用uni.createInnerAudioContext 替代</td>\n    </tr>\n    <tr>\n        <td >live-player</td>\n        <td>直播播放</td>\n    </tr>\n    <tr>\n        <td >live-pusher</td>\n        <td>实时音视频录制，也称直播推流</td>\n    </tr>\n    <tr>\n        <td >媒体组件</td>\n        <td >audio</td>\n        <td>不再维护，使用uni.createInnerAudioContext 替代</td>\n    </tr>\n    <tr>\n        <td >地图</td>\n        <td >map</td>\n        <td>\n            组件的宽/高推荐写直接量，比如：750rpx，不要设置百分比值。<br/>\n            uni-app 只支持 gcj02 坐标\n        </td>\n    </tr>\n    <tr>\n        <td >画布</td>\n        <td >canvas</td>\n        <td>\n            1.默认宽度300px、高度 225px，大小后需要重新绘制<br/>\n            2.同一页面中的 canvas-id 不可重复,否则画布将被隐藏<br/>\n            3.微信、百度、QQ小程序中层级高于前端组件,不可内嵌在 scroll-view、swiper、picker-view、movable-view 中使用\n        </td>\n    </tr>\n     <tr>\n        <td >webview</td>\n        <td >web-view</td>\n        <td>\n            1.小程序仅支持加载网络网页，不支持本地html<br/>\n            2.小程序端 web-view 组件一定有原生导航栏，下面一定是全屏的 web-view 组件，navigationStyle: custom 对 web-view 组件无效。\n        </td>\n    </tr>\n</table>\n```\n\n+ uni-app扩展组件(即uni-ui)是DCloud提供的一个跨端ui库，它是基于vue组件的、flex布局的、无dom的跨全端ui框架,它是基础组件的补充。  \n   如果创建项目时没有选择`hello uni-app`模板，则可使用npm引入uni-ui  \n   `npm install @dcloudio/uni-ui`  \n   uni-ui目前小程序和混合app领域，暂时还没有比uni ui更高性能的框架。在满足业务条件的情况下不要使用自定义组件。 \n   注:uni-ui 不支持使用 Vue.use() 的方式安装\n+ uni-app第三方插件市场及本地自定义组件是对以上两种组件的补充\n\n#### 2. vue组件\nuni-app只支持vue单文件组件,所以在使用第三方组件如：npm引入某组件的时候应注意。有些原生vue支持的组件在uni-app中是错误的组件,例如： \n\n```\n// uni-app不支持的组件\n//  1.动态组件\n<component v-bind:is=\"currentTabComponent\"></component>\n//  2.异步组件\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n// 3.包含自定义render的组件\n<script>\n    ...\n    export default {\n        data() {\n            return { }\n        },\n        ...\n        render (createElement) {\n            return createElement(...)\n        }\n     }\n</script>\n```\n\n组件的引用兼容了vue及小程序  \n使用方式1：在src目录下创建/component目录存放组件，以插件市场中的uni-goods-nav为例:  \n   1. 插件市场中下载组件包(https://ext.dcloud.net.cn/plugin?id=865)\n   2. 解压后将goods-nav目录放置在component目录下\n   3. 引入插件、注册、使用，与常规vue开发一模一样\n\n```\n<template>\n    <view>\n        <view class=\"goods-carts\">\n            <uni-goods-nav :options=\"options\" :button-group=\"buttonGroup\" />\n        </view>\n    </view>\n</template>\n<script>\n    import uniGoodsNav from '@/components/uni-goods-nav/uni-goods-nav.vue'\n    export default {\n        components: { uniGoodsNav },\n        data() {\n            return {\n                options: [{\n                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/kefu.png',\n                    text: '客服'\n                }, {\n                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/dianpu.png',\n                    text: '店铺'\n                }, {\n                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/carts.png',\n                    text: '购物车',\n                    info: 2\n                }],\n                buttonGroup: [{\n                        text: '加入购物车',\n                        backgroundColor: '#ffa200 ',\n                        color: '#fff'\n                    },\n                    {\n                        text: '立即购买',\n                        backgroundColor: '#ff0000',\n                        color: '#fff'\n                    }\n                ]\n            }\n        }\n    }\n</script>\n```\n\n使用方式2： 与方式1一样，但使用组件时与小程序一样在pages.json中引入组件  \n```\n{\n    \"path\": \"subPages/demo/uni-goods-nav\",\n    \"style\": {\n            \"navigationBarTitleText\": \"购物车\",\n            \"usingComponents\": {\n            \"uni-goods-nav\": \"/components/uni-goods-nav/uni-goods-nav\"\n    }\n}\n```\n\n得到的效果:  \n![购物车](/images/gwc.png)  \n熟悉web开发的前端开发者都习惯从npm仓库中获取组件，所以很多时候觉得通过下载组件包然后解压的方式显得很怪异，实际上uni-app是支持npm方式引入组件的，只是这有很大风险会有部分平台不支持的问题。可以通过条件编译来屏蔽不支持的平台。以mpvue-echarts为例  \n```\n// npm安装包\nnpm install echarts mpvue-echarts --save\n// echarts-weixin.vue\n<template>  \n    <div class=\"container\">  \n        <mpvue-echarts :echarts=\"echarts\" :onInit=\"onInit\" />  \n    </div>  \n</template>  \n<script>  \n    import * as echarts from 'echarts'  \n    import mpvueEcharts from 'mpvue-echarts'  \n    export default { \n        components: {  mpvueEcharts  },  \n        data() {  \n            return {  \n                echarts,  \n                onInit: function (canvas, width, height) {\n                ...\n                }\n            }  \n        }\n    }  \n</script>\n// echarts-h5.vue\n<script>\nimport * as echarts from 'echarts'\nvar myChart = echarts.init(document.getElementById('echarts'));\nmyChart.setOption({\n    ...\n})\n</script>\n// pages.json\n#ifdef MP-WEIXIN\n{\n    \"path\": \"pages/demo/echarts-weixin\",\n    \"style\": {\n        \"navigationBarTitleText\": \"demo-echarts\"\n    }\n},\n#endif\n#ifdef H5\n{\n    \"path\": \"pages/demo/echarts-h5\",\n    \"style\": {\n        \"navigationBarTitleText\": \"demo-echarts\"\n    }\n},\n#endif\n```\n\n#### 3. 微信小程序组件\n由于性能问题，开发中应尽量避免直接使用小程序的组件。但是uni-app仍然 支持在App 和 小程序 中使用小程序自定义组件。  \n   1. 在项目src目录下新建小程序组件放置目录，微信及QQ-wxcomponents/支付宝-mycomponents/百度-swancomponents/头条-ttcomponents\n   2. 在 pages.json 对应页面的 style -> usingComponents 引入组件\n   3. 页面中使用组件\n\n以有赞的vant-weapp button组件为例\n1. 下载组件并放置到wxcomponents目录下:  \n    `npm i @vant/weapp -S --production` \n    复制node_modules/@vant/weapp/dist/button到wxcomponents/vant/下\n2. pages.json 中使用组件  \n```\n{\n  \"usingComponents\": {\n    \"van-button\": \"/wxcomponents/vant/button/index\"\n  },\n  \"navigationBarTitleText\": \"test-vant\"\n}\n```\n\n3. demo-test-wx.vue  \n```\n<template>\n    <view>\n        <view class=\"uni-common-mt\" style=\"text-align: center;\">\n            <van-button type=\"primary\" @click=\"onClick\">vant按钮组件</van-button>\n        </view>\n    </view>\n</template>\n<script>\n    export default {\n        data() {\n            return {\n                checked: true\n            };\n        },\n        methods: {\n            onClick() {\n                uni.showToast({\n                    title: \"uni-app支持在微信小程序、QQ小程序端、App端、H5端引入微信小程序自定义组件。\",\n                    mask: false,\n                    icon: \"none\",\n                    duration: 3000\n                });\n            }\n        }\n    }\n</script>\n```\n\n效果：  \n![结果](/images/test-vant.png)\n\n","tags":["uni-app","vuejs","小程序","跨多端"]},{"title":"uni-app基础学习笔记","url":"/posts/55711/","content":"## uni-app基础学习笔记\n#### 1. uni-app介绍\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，一套代码可编译到iOS、Android、H5、小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台（可以通过条件编译区分各平台特殊代码）。uni-app完整支持vue生命周期和模板语法，如果会vue基本上就可以解决大多数问题了，学习成本非常低。(暂时绕开了原生APP开发相关如nvue，h5+等内容)  \n![uni-app功能框架图](/images/uni0124.png)  \n官方演示用例(https://github.com/dcloudio/hello-uniapp )可快速体验和学习框架的常用组件和案例  \n![通用快码](/images/demoQrCode.png)\n\n#### 2. uni-app编码统一规范\n   + 页面组件遵循Vue 单文件组件 (SFC) 规范  \n   + 组件标签靠近微信小程序规范  \n   + 接口能力（JS API）靠近微信小程序规范  \n   + 数据绑定及事件处理靠近 Vue.js 规范，同时补充了App及页面的生命周期  \n   + 为兼容多端运行，建议使用flex布局进行开发  \n\n#### 3. 创建uni-app项目注意事项\n   + 可通过HBuilderX可视化界面、vue-cli命令行两种方式快速创建项目。  \n   + 官方推出的 HBuilderX 编辑器，内置相关环境，开箱即用  \n   + uni-app在发布到H5时支持所有vue的语法  \n   + cli版如果想安装less、scss、ts等编译器，需自己手动npm安装。在HBuilderX的插件管理界面安装无效，那个只作用于HBuilderX创建的项目。  \n   + HBuilderX云打包可以使用Dcloud公用开发者证书进行测试，或者使用自己的开发者证书。  \n\n#### 4. 项目迁移注意事项\n###### (1)  H5项目迁移至uni-app  \n   + 后缀名是.html，需要改为.vue，并注意遵循vue单文件组件SFC规范\n   + uni-app默认是小程序的路由方式(pages.json管理页面)，如果使用vue-rooter的话可以使    用uni-simple-router等第三方插件做兼容\n   + 静态文件挪到static目录（静态资源只能存放于此）\n   + 使用scroll-view、swiper等原生组件替换H5组件\n   + audio组件使用uni.getBackgroundAudioManager()替换\n   + v-html使用rich-text组件或uparse扩展插件替换\n   + uni-app非H5端不支持window、navigator、document等web专用对象，使用条件编译区       分\n   + 不支持 *选择器及部分新的css  \n \n###### (2) 微信小程序转换uni-app指南及转换器：https://ask.dcloud.net.cn/article/35786\n\n#### 5. 关于uni-app生命周期\nuni-app 完整支持 Vue 实例的生命周期，此外新增应用生命周期及页面生命周期。\n<table><tr><th colspan=\"2\" style=\"text-align:left;\">应用生命周期</th></tr>\n<tr><td>onLaunch</td><td>初始化完成时触发（全局只触发一次）</td></tr>\n<tr><td>onShow</td><td>启动或从后台进入前台显示时触发</td></tr>\n<tr><td>onHide</td><td>从前台进入后台时触发</td></tr>\n<tr><td>onError</td><td>报错时触发</td></tr>\n<tr><td>onUniNViewMessage</td><td>监听nvue页面发送的数据</td></tr></table>\n注:应用生命周期仅可在App.vue中监听，在其它页面监听无效。在onlaunch生命周期内进行页面的跳转可能会和pages.json内配置的第一个页面跳转冲突,造成白屏，需要进行延时跳转。\n<table style=\"text-align:left;\"><tr><th colspan=\"2\">页面生命周期（部分常用）</th></tr>\n<tr><td>onLoad</td><td>监听页面加载，参数类型为Object，类似微信小程序</td></tr>\n<tr><td>onShow</td><td>监听页面显示，包括从下级页面返回当前页面</td></tr>\n<tr><td>onReady</td><td>监听页面初次渲染完成，如果渲染速度快，会在页面进入动画完成前触发</td></tr>\n<tr><td>onPullDownRefresh</td><td>监听用户下拉动作，一般用于下拉刷新</td></tr>\n<tr><td>onReachBottom</td><td>页面上拉触底事件的处理函数</td></tr>\n<tr><td>onShareAppMessage</td><td>用户点击右上角分享(小程序)</td></tr>\n<tr><td>onBackPress</td><td>监听页面返回(https://ask.dcloud.net.cn/article/35120)</td></tr></table>\n关于.nvue页面(即Native vue)：uni-app App端内置 weex 渲染引擎，提供了原生渲染能力，但是weex提供的api不完整,nuve相当于给weex补充了大量组件和api，以及丰富的Plus API、Native.js、原生插件。(详情: https://ask.dcloud.net.cn/article/36074)\n\n#### 6. 关于uni-app组件注意事项\n   + 非H5端需要注意Slot不支持scoped，不支持动态组件、异步组件、inline-template、X-Templates、keep-alive、transition\n   + uni-app 内置了小程序的所有组件，但原生组件上的事件绑定需要以vue语法来写(bindchange=”xxx”等改成@change=”xxx”)\n   + uni-app组件有命名限制，组件名最好有特殊前缀或后缀(参考: https://uniapp.dcloud.io/use?id=%e5%91%bd%e5%90%8d%e9%99%90%e5%88%b6 )\n   + uni-app内置了vuex\n   + uni-app支持小程序自定义组件(wxcomponents目录下)，但是小程序组件的性能不如vue组件，不建议使用,另外小程序自定义组件只能在pages.json中配置 usingComponents,不支持页面引用。(参考:  https://ask.dcloud.net.cn/article/35786 )\n\n#### 7. 条件编译\n   + 用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。uni-app支持ifdef和ifndef(除了xx平台)，多个平台用||连接。例:\n```\n#ifdef H5||APP-PLUS\n需条件编译的代码\n#endif\n```\n   + 如果想把各平台的页面文件更彻底的分开，也可以在uni-app项目根目录创建platforms目录，然后在下面创建APP-PLUS、MP-WEIXIN等子目录，存放不同平台的文件。\n   + 静态资源按不同平台区分的可在static目录下新建平台目录(注意使用小写，如：mp-weixin等)\n\n#### 8. 部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法）\n   + 各家小程序的浏览器内核不同，会造成css兼容性问题(参考：https://ask.dcloud.net.cn/article/1318 )\n   + 各家小程序存在不一样的支持度(如：支付宝小程序不支持ECharts，百度小程序不支持v-if和for同时使用)，遇到相关问题可关注是否有相应版本更新或使用条件编译来不同平台不同处理。\n   + 微信小程序端的原生组件存在层级问题，可以用cover-view、cover-image来进行覆盖\n   + uni-app中可以使用upx作为自适应单位，但不支持动态绑定，可以使用uni.upx2px转化为px。\n   + 关于Class 与 Style 绑定，非H5端支持简单的样式绑定，绑定的值只能是字符串，不支持复杂的绑定，比如:class=\"[class-a,class-b]\"\n\n#### 9. 使用总结\n   + uni-app官方文档( https://uniapp.dcloud.io/README )非常详细，对于初学和使用uni-app非常有帮助\n   + 因基本完整支持vue的语法及特性,uni-app的学习成本很低\n   + 对于跨端uni-app最好是以小程序的编码方式为主向其他端扩展，参考以上第3条H5项目迁移至uni-app\n   + 开发工具官方推荐HBuilderX，对于惯用Sublime/Atom等编辑器的开发者可以平滑过渡，其他开发者使用vue-cli的方式也很方便，但是仍然需要HbuilderX打包到安卓/IOS(无需打包原生APP的忽略)\n   + 目前uni-app插件市场( https://ext.dcloud.net.cn/ )有1K+第三方插件，但是质量良莠不齐只能筛选后使用和参考\n   + uni-app支持使用npm安装第三方包，但是为多端兼容考虑应优先从uni-app插件市场获取插件，直接从npm下载库很容易只兼容H5端，当然也可使用条件编译将该部分特殊处理\n\n总体来说uni-app是一个非常好的跨平台开发框架，框架本身的文档也非常详细，但是目前开放生态并不是很完善，很多第三方插件文档也很模糊，如果单纯只开发某一个平台的代码可以绕开uni-app，但是如果是跨端需求则非常适合用uni-app，因为使用条件编译进行各平台的独有代码开发也没有增加工作量。uni-app在跨端抹平度、扩展灵活性、性能体验、学习成本、开发成本等方面都非常优秀(官方说的8个指标虽有广告成分但也确实很优秀)。","tags":["uni-app","vuejs","小程序","跨多端"]}]