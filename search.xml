<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http学习笔记</title>
      <link href="/posts/17159/"/>
      <url>/posts/17159/</url>
      
        <content type="html"><![CDATA[<h2 id="http学习笔记"><a href="#http学习笔记" class="headerlink" title="http学习笔记"></a>http学习笔记</h2><h4 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1.http协议"></a>1.http协议</h4><ul><li>http是一个简单的纯文本、无状态的、面向连接的应用层协议，通常运行在TCP之上，目前http最新版本是2.0。  </li><li>http协议请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。  </li><li>http请求报文包括:请求行、请求头部、空行、请求数据。<br><img src="/images/http-01.jpg" alt="请求报文结构">  </li><li>http应答报文包括:状态行、响应头、空行、数据。<br><img src="/images/http-02.png" alt="响应报文结构">  </li><li>http协议运行在OSI七层概念模型中的应用层<br><img src="/images/http-04.png" alt="OSI七层概念模型"><ul><li>应用层：负责解决业务问题  </li><li>表示层：负责把网络中的消息转换成应用层可以读取的消息  </li><li>会话层：负责建立会话、握手、维持连接、关闭  </li><li>传输层：负责解决进程与进程之间的通信，例如TCP保证报文的可达性和流量的控制  </li><li>网络层：负责解决广域网（Internet）中主机之间数据的传递<br>网络层  </li><li>数据链路层：负责局域网中根据MAC地址连接的相应的交换机/路由器进行报文的转发  </li><li>物理层：物理传输介质  </li></ul></li></ul><h4 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h4><p>HTTP是基于客户/服务器模式，且面向连接的。典型场景是浏览器发起HTTP请求：  </p><ol><li>服务器监听80等web端口，浏览器从URL中解析出域名  </li><li>浏览器根据域名查询DNS从而获取到对于的IP地址  </li><li>通过查询到的IP地址与服务器建立TCP链接（如果是https协议还需要万TLS/SSL握手）  </li><li>构造HTTP请求，在这个过程中填充上下文至HTTP头部  </li><li>浏览器发送HTTP请求，服务器收到HTTP请求后将HTML页面作为包体返回给浏览器  </li><li>浏览器引擎解析响应，渲染包体至用户界面，并根据超链接构造其他的HTTP请求<br><img src="/images/http-03.png" alt="浏览器发起HTTP请求背后">  </li></ol><h4 id="3-http的各种版本"><a href="#3-http的各种版本" class="headerlink" title="3.http的各种版本"></a>3.http的各种版本</h4><p>http发展至今经历了0.9/1.0/1.1/2.0四个版本，目前大部分网站使用的是http1.0/1.1协议，http2.0还在普及中。</p><ul><li>0.9协议就是一个交换信息的无序协议，仅仅限于文字，1.0协议对每一次请求/响应建立并拆除一次连接，其特点是简单、易于管理，1.1在1.0基础上支持持久连接, 可以在同一个tcp的连接中可以传送多个HTTP请求和响应，2.0在1.0和1.1两个版本的基础上引入二进制数据帧和流的概念</li><li>在http协议的发展历程中还有两个重要的协议https和spdy</li></ul><h4 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4.HTTPS"></a>4.HTTPS</h4><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版，不同于HTTP基于应用层,HTTPS基于传输层  </p><ul><li>HTTPS协议的主要功能基本都依赖于TLS/SSL协议<br><img src="/images/http-05.png" alt="TLS/SSL协议"></li><li>通过第三方机构CA和证书确保服务器身份的合法性<br><img src="/images/http-06.png" alt="TLS/SSL协议">  <ul><li>证书=公钥+申请者与颁发者信息+签名</li><li>CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。</li></ul></li><li>HTTPS优势在于身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但代价是HTTPS协议的性能损耗，包括增加延时(握手过程)以及消耗较多的CPU资源(RSA解密等)</li></ul><h4 id="5-SPDY及HTTP2-0"><a href="#5-SPDY及HTTP2-0" class="headerlink" title="5.SPDY及HTTP2.0"></a>5.SPDY及HTTP2.0</h4><p>SPDY是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY是对HTTP协议的增强。特性：</p><ul><li>单连接多路复用。在同一个域名下，SPDY只使用一个连接来加载一个页面的所有资源，在这个连接中可以打开多个流来同时传输数据</li><li>全双工，支持服务器推送。SPDY的流是双向的，允许服务器主动的同客户端建立流。SPDY通过Server Push和Server Hint技术，主动的向客户端推送资源，同时不发送已经缓存的资源<ul><li>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</li><li>server暗示（server hint）和server push不同的是，server hint并不会主动推送内容，只是告诉有新的内容产生，内容的下载还是需要客户端主动发起请求。一般应用场景是客户端需要先查询server状态，然后再下载资源，可以节约一次查询请求。</li></ul></li><li>压缩HTTP头：SPDY通过zlib对HTTP头进行了压缩，并强制开启HTTP BODY的Gzip压缩</li><li>请求分级，重要的资源优先传送。SPDY通过建立0~7的优先级，使服务器会优先处理优先级高的请求</li><li>强制使用 SSL传输协议：SPDY为了安全强制使用安全协议，通过压缩和优先级策略来弥补安全协议的性能问题<br>存在的问题</li><li>多域名请求下同样要建立多条连接</li><li>SSL/TLS协议的性能问题</li><li>所有头部名都需要小写</li><li>客户端必须支持 gzip 压缩</li><li>Google已经不再支持SPDY</li></ul><p>HTTP2.0是SPDY的升级，它采用了SPDY很多的特性和技术，但和SPDY还是有区别：</p><ul><li>HTTP2.0支持明文传输，SPDY强制使用SSL/TLS</li><li>HTTP2.0采用HPACK算法压缩消息头</li><li>HTTP2.0对数据报文重新定义了二进制格式  </li></ul><p>HTTP2.0消息被分成很小的消息和帧,然后每个消息和帧用二进制编码。客户端和服务端都采用二进制编码和解码。</p><blockquote><p>流：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。<br>消息：一个完整的帧序列，它映射到逻辑的请求和响应消息。<br>帧：在HTTP/2通信的最小单元。每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流。  </p></blockquote><ul><li>所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。</li><li>每个流都有独一无二的标志和优先级。</li><li>每个消息都是逻辑上的请求和相应消息。由一个或者多个帧组成。</li><li>来自不同流的帧可以通过帧头的标志来关联和组装起来。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>koa基础学习笔记</title>
      <link href="/posts/44367/"/>
      <url>/posts/44367/</url>
      
        <content type="html"><![CDATA[<h2 id="koa基础学习笔记"><a href="#koa基础学习笔记" class="headerlink" title="koa基础学习笔记"></a>koa基础学习笔记</h2><h4 id="1-koa概况"><a href="#1-koa概况" class="headerlink" title="1.koa概况"></a>1.koa概况</h4><p>Koa 是一个简单好用的nojdejs web框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码极简，所有功能都通过插件实现。<br>koa1.x和koa2.x两个区别比较大，koa1.x使用generator控制项目同步，koa2.x使用ES7的async函数。大部分的中间件目前已经做了针对koa2.x的兼容。没有做兼容的中间件，可以使用 koa-convert中间件把generator转化一下。例: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const convert &#x3D; require(&#39;koa-convert&#39;);</span><br><span class="line">const staticCache &#x3D; require(&#39;koa-static-cache&#39;);</span><br><span class="line">app.use(convert(staticCache(path.join(__dirname, &#39;public&#39;), &#123; maxAge: 365 * 24 * 60 * 60 &#125;)));</span><br></pre></td></tr></table></figure><p>基本用法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">app.use((ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#96;$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;&#96;);</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><h4 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2.中间件"></a>2.中间件</h4><p>Koa所有功能都使用中间件（middleware）来实现。每个中间件默认接受两个参数，第一个参数是Context对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件。多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。<br><img src="/images/72150-0e1846c8c7bdf999.webp" alt="中间件的洋葱结构">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const one &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; one&#39;);</span><br><span class="line">next();</span><br><span class="line">console.log(&#39;&lt;&lt; one&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const two &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; two&#39;);</span><br><span class="line">next(); </span><br><span class="line">console.log(&#39;&lt;&lt; two&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const three &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; three&#39;);</span><br><span class="line">next();</span><br><span class="line">console.log(&#39;&lt;&lt; three&#39;);</span><br><span class="line">&#125;</span><br><span class="line">app.use(one);</span><br><span class="line">app.use(two);</span><br><span class="line">app.use(three);</span><br></pre></td></tr></table></figure><p>如果中间件内部没有调用next函数，那么执行权就不会传递下去。<br><img src="/images/2020-03-03-18-44-49.png" alt="运行效果"><br>注释two后<br><img src="/images/2020-03-03-18-44-27.png" alt="运行效果"><br>异步中间件与同步中间件混合使用时，注意next之后的代码执行顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const logger &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#96;$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;&#96;);</span><br><span class="line">next();</span><br><span class="line">&#125;</span><br><span class="line">const one &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; one&#39;);</span><br><span class="line">next();</span><br><span class="line">console.log(&#39;&lt;&lt; one&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const two &#x3D; async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; two&#39;);</span><br><span class="line">await next(); </span><br><span class="line">console.log(&#39;&lt;&lt; two&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const three &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; three&#39;);</span><br><span class="line">next();</span><br><span class="line">console.log(&#39;&lt;&lt; three&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const four &#x3D; async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;&gt;&gt; four&#39;);</span><br><span class="line">await next();</span><br><span class="line">console.log(&#39;&lt;&lt; four&#39;);</span><br><span class="line">ctx.body &#x3D; &#39;tets.......&#39;</span><br><span class="line">&#125;</span><br><span class="line">app.use(logger);</span><br><span class="line">app.use(one);</span><br><span class="line">app.use(two);</span><br><span class="line">app.use(three);</span><br><span class="line">app.use(four);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><p><img src="/images/2020-03-04-13-07-20.png" alt="运行效果"></p><h4 id="3-重要的对象及函数"><a href="#3-重要的对象及函数" class="headerlink" title="3.重要的对象及函数"></a>3.重要的对象及函数</h4><ul><li>next<br>next函数主要负责将控制权交给下一个中间件，如果当前中间件没有终结请求，并且next没有被调用，那么当前中间件的请求将被挂起，等到next()后的中间件执行完再返回继续执行。  </li><li>ctx.res<br>Node 的 response 对象。<br>Koa不支持直接调用底层res进行响应处理，避免使用res.statusCode、res.writeHead()、res.write()、res.end()    </li><li>response.body=<br>String: Content-Type默认为text/html或者text/plain，两种默认charset均为utf-8。 Content-Length 同时会被设置。<br>Buffer: Content-Type默认为application/octet-stream，Content-Length同时被设置。<br>Stream: Content-Type默认为application/octet-stream。<br>Object: Content-Type默认为application/json。这包括普通对象{ foo: ‘bar’ }和数组[‘foo’, ‘bar’]。<br>当stream被设置为响应体时，.onerror将作为监听器自动添加到错误事件中以捕获任何错误。此外，每当请求被关闭（甚至更早）时，stream都将被销毁。如果不想要这两个功能，请不要直接将stream设置为响应体。<br>如果res.status没有赋值，Koa会自动设置为200或204。  </li><li>app.listen  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.listen(handle[, backlog][, callback])</span><br><span class="line">server.listen(options[, callback])</span><br><span class="line">server.listen(path[, backlog][, callback]) 用于 IPC 服务器。</span><br><span class="line">server.listen([port[, host[, backlog]]][, callback]) 用于 TCP 服务器。</span><br></pre></td></tr></table></figure><p>这个函数是异步的。当服务器开始监听时，会触发 ‘listening’ 事件。 最后一个参数 callback 将被添加为 ‘listening’ 事件的监听器。<br>所有的 listen() 方法都可以使用一个 backlog 参数来指定待连接队列的最大长度。 实际的长度将由操作系统的 sysctl 设置决定。此参数的默认值是 511<br>当且仅当上次调用 server.listen() 发生错误或已经调用 server.close() 时，才能再次调用 server.listen() 方法。<br>path是IPC连接的识别路径( <a href="http://nodejs.cn/api/net.html#net_identifying_paths_for_ipc_connections" target="_blank" rel="noopener">http://nodejs.cn/api/net.html#net_identifying_paths_for_ipc_connections</a> )  </p><h4 id="4-常用中间件"><a href="#4-常用中间件" class="headerlink" title="4.常用中间件"></a>4.常用中间件</h4><ul><li>表单处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const koaBody &#x3D; require(&#39;koa-body&#39;);</span><br><span class="line">const main &#x3D; async function(ctx) &#123;</span><br><span class="line">const body &#x3D; ctx.request.body;</span><br><span class="line">if (!body.name) ctx.throw(400, &#39;.name required&#39;);</span><br><span class="line">ctx.body &#x3D; &#123; name: body.name &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">app.use(koaBody());</span><br></pre></td></tr></table></figure><ul><li>文件上传</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const os &#x3D; require(&#39;os&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const koaBody &#x3D; require(&#39;koa-body&#39;);</span><br><span class="line">const main &#x3D; async function(ctx) &#123;</span><br><span class="line">const tmpdir &#x3D; os.tmpdir();</span><br><span class="line">const filePaths &#x3D; [];</span><br><span class="line">const files &#x3D; ctx.request.body.files || &#123;&#125;;</span><br><span class="line">for (let key in files) &#123;</span><br><span class="line">    const file &#x3D; files[key];</span><br><span class="line">    const filePath &#x3D; path.join(tmpdir, file.name);</span><br><span class="line">    const reader &#x3D; fs.createReadStream(file.path);</span><br><span class="line">    const writer &#x3D; fs.createWriteStream(filePath);</span><br><span class="line">    reader.pipe(writer);</span><br><span class="line">    filePaths.push(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"> ctx.body &#x3D; filePaths;</span><br><span class="line">&#125;;</span><br><span class="line">app.use(koaBody(&#123; multipart: true &#125;));</span><br></pre></td></tr></table></figure><ul><li>路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  var route &#x3D; require(&#39;koa-route&#39;);</span><br><span class="line">&#x2F;&#x2F;引入中间件之后支持的写法差不多，只是路径传入route，然后把route作为中间件挂载到app</span><br><span class="line">app.use(route.get(&#39;&#x2F;&#39;, list));</span><br><span class="line">app.use(route.get(&#39;&#x2F;post&#x2F;new&#39;, add));</span><br><span class="line">app.use(route.get(&#39;&#x2F;post&#x2F;:id&#39;, show));</span><br><span class="line">app.use(route.post(&#39;&#x2F;post&#39;, create));</span><br><span class="line">&#x2F;&#x2F;链式写法</span><br><span class="line">var router &#x3D; require(&#39;koa-router&#39;)();</span><br><span class="line">router.get(&#39;&#x2F;&#39;, list)</span><br><span class="line">    .get(&#39;&#x2F;post&#x2F;new&#39;, add)</span><br><span class="line">    .get(&#39;&#x2F;post&#x2F;:id&#39;, show)</span><br><span class="line">    .post(&#39;&#x2F;post&#39;, create);</span><br><span class="line">app.use(router.routes())</span><br><span class="line">   .use(router.allowedMethods());</span><br></pre></td></tr></table></figure><ul><li>网页模板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var views &#x3D; require(&#39;co-views&#39;);</span><br><span class="line">var render &#x3D; views(&#39;tpls&#39;, &#123;</span><br><span class="line">    map: &#123; html: &#39;swig&#39; &#125;,&#x2F;&#x2F;html后缀使用引擎</span><br><span class="line">    default: &quot;jade&quot;&#x2F;&#x2F;render不提供后缀名时</span><br><span class="line">&#125;);</span><br><span class="line">var userInfo &#x3D; &#123;</span><br><span class="line">    name: &#39;tobi&#39;,</span><br><span class="line">    species: &#39;ferret&#39;</span><br><span class="line">&#125;;</span><br><span class="line">var html;</span><br><span class="line">html &#x3D; render(&#39;user&#39;, &#123; user: userInfo &#125;);</span><br><span class="line">html &#x3D; render(&#39;user.jade&#39;, &#123; user: userInfo &#125;);</span><br><span class="line">html &#x3D; render(&#39;user.ejs&#39;, &#123; user: userInfo &#125;);</span><br></pre></td></tr></table></figure><h4 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5.错误处理"></a>5.错误处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">&#x2F;&#x2F; 错误处理中间件, 洋葱最外层</span><br><span class="line">app.use(async (ctx, next)&#x3D;&gt;&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await next();</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        &#x2F;&#x2F; 响应用户</span><br><span class="line">        ctx.status &#x3D; error.statusCode || error.status || 500;</span><br><span class="line">        ctx.body &#x3D; error.message;</span><br><span class="line">        ctx.app.emit(&#39;error&#39;, error); &#x2F;&#x2F; 触发应用层级错误事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(async (ctx, next)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;前置操作&quot;);</span><br><span class="line">    await next();</span><br><span class="line">    console.log(&quot;后置操作&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(ctx&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; 抛出错误, 也可以理解为模拟错误发生</span><br><span class="line">    throw new Error(&quot;未知错误&quot;);</span><br><span class="line">    console.log(&quot;执行任务...&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 全局错误事件监听</span><br><span class="line">app.on(&#39;error&#39;, (error)&#x3D;&gt;&#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 语法糖, 等同于http.createServer(app.callback()).listen(3000);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app组件学习笔记</title>
      <link href="/posts/63461/"/>
      <url>/posts/63461/</url>
      
        <content type="html"><![CDATA[<h2 id="uni-app中的各种组件"><a href="#uni-app中的各种组件" class="headerlink" title="uni-app中的各种组件"></a>uni-app中的各种组件</h2><p>通过之前uni-app基础学习了解到uni-app是一个海纳百川的框架，它支持各种各样的组件及编码方式。虽然官网推荐使用插件市场的uni-app原生插件代替微信小程序等其他规范的组件，但更多的时候我们都有自己工作中积累的自定义组件，所以如何平滑的迁移到目标平台也是我们关注的一个重点。<br>开始前的准备:  </p><ul><li>通过CLI创建项目<br><code>vue create -p dcloudio/uni-preset-vue my-test</code></li><li>选择默认模板新建一个空项目<br><img src="/images/h5-cli-01.png" alt="选择模板"></li><li>以H5方式运行项目  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>(由于写文时条件限制我的电脑是linux系统，没有安装微信/支付宝等开发者工具，以下运行效果图皆只有H5平台，后续补充)<h4 id="1-uni-app组件"><a href="#1-uni-app组件" class="headerlink" title="1. uni-app组件"></a>1. uni-app组件</h4>uni-app组件大致分为内置组件、官方扩展组件、第三方uni-app插件，几乎所有组件都有各自自定义的属性，可以对该组件的功能或样式进行修饰  </li><li>uni-app内置组件是最常用的，与微信内置组件相同。基础组件分为以下八大类（以下列出部分组件的注意点）：  </li></ul><table>    <tr>        <th>类别</th>        <th>组件</th>        <th>描述及注意事项</th>    </tr >    <tr >        <td rowspan="3">视图容器</td>        <td>view</td>        <td>视图容器，类似于HTML中的div</td>    </tr>    <tr>        <td>scroll-view</td>        <td>            1.scroll-view 不适合放长列表，有性能问题。长列表滚动和下拉刷新，应该使用原生导航栏搭配页面级的滚动和下拉刷新实现。<br/>            2.scroll-view是区域滚动，不会触发页面滚动，无法触发pages.json配置的下拉刷新、页面触底onReachBottomDistance、titleNView的transparent透明渐变。        </td>    </tr>    <tr>        <td>swiper</td>        <td>                1.swiper是单页组件，适合做banner图轮播和简单列表左右滑动。<br/>                2.因为性能问题，swiper不适合做复杂的长列表。        </td>    </tr>    <tr>        <td rowspan="4">基础内容组件</td>        <td>icon</td>        <td>图标</td>    </tr>    <tr>        <td>text</td>        <td>            1.组件内只支持嵌套text组件，不支持其它组件或自定义组件，否则会引发在不同平台的渲染差异。            2.支持 \n 方式换行。        </td>    </tr>    <tr>        <td>rich-text</td>        <td>富文本,支付宝小程序 nodes 属性只支持使用 Array 类型</td>    </tr>    <tr>        <td>progress</td>        <td>进度条</td>    </tr>    <tr>        <td rowspan="2">表单组件</td>        <td>picker</td>        <td>弹出式列表选择器</td>    </tr>    <tr>        <td>picker-view</td>        <td>窗体内嵌式列表选择器</td>    </tr>    <tr>        <td >导航</td>        <td >navigator</td>        <td>页面链接。类似于HTML中的a标签</td>    </tr>    <tr>        <td rowspan="3" >媒体组件</td>        <td >audio</td>        <td>不再维护，使用uni.createInnerAudioContext 替代</td>    </tr>    <tr>        <td >live-player</td>        <td>直播播放</td>    </tr>    <tr>        <td >live-pusher</td>        <td>实时音视频录制，也称直播推流</td>    </tr>    <tr>        <td >媒体组件</td>        <td >audio</td>        <td>不再维护，使用uni.createInnerAudioContext 替代</td>    </tr>    <tr>        <td >地图</td>        <td >map</td>        <td>            组件的宽/高推荐写直接量，比如：750rpx，不要设置百分比值。<br/>            uni-app 只支持 gcj02 坐标        </td>    </tr>    <tr>        <td >画布</td>        <td >canvas</td>        <td>            1.默认宽度300px、高度 225px，大小后需要重新绘制<br/>            2.同一页面中的 canvas-id 不可重复,否则画布将被隐藏<br/>            3.微信、百度、QQ小程序中层级高于前端组件,不可内嵌在 scroll-view、swiper、picker-view、movable-view 中使用        </td>    </tr>     <tr>        <td >webview</td>        <td >web-view</td>        <td>            1.小程序仅支持加载网络网页，不支持本地html<br/>            2.小程序端 web-view 组件一定有原生导航栏，下面一定是全屏的 web-view 组件，navigationStyle: custom 对 web-view 组件无效。        </td>    </tr></table>每个组件都有其特定的属性，详细+ uni-app扩展组件(即uni-ui)是DCloud提供的一个跨端ui库，它是基于vue组件的、flex布局的、无dom的跨全端ui框架,它是基础组件的补充。     如果创建项目时没有选择`hello uni-app`模板，则可使用npm引入uni-ui     `npm install @dcloudio/uni-ui`     uni-ui目前小程序和混合app领域，暂时还没有比uni ui更高性能的框架。在满足业务条件的情况下不要使用自定义组件。    注:uni-ui 不支持使用 Vue.use() 的方式安装+ uni-app第三方插件市场及本地自定义组件是对以上两种组件的补充<h4 id="2-vue组件"><a href="#2-vue组件" class="headerlink" title="2. vue组件"></a>2. vue组件</h4><p>uni-app只支持vue单文件组件,所以在使用第三方组件如：npm引入某组件的时候应注意。有些原生vue支持的组件在uni-app中是错误的组件,例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; uni-app不支持的组件</span><br><span class="line">&#x2F;&#x2F;  1.动态组件</span><br><span class="line">&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">&#x2F;&#x2F;  2.异步组件</span><br><span class="line">Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: &#39;&lt;div&gt;I am async!&lt;&#x2F;div&gt;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 3.包含自定义render的组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    ...</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123; &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">        render (createElement) &#123;</span><br><span class="line">            return createElement(...)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">组件的引用兼容了vue及小程序  </span><br><span class="line">使用方式1：在src目录下创建&#x2F;component目录存放组件，以插件市场中的uni-goods-nav为例:  </span><br><span class="line">   1. 插件市场中下载组件包(https:&#x2F;&#x2F;ext.dcloud.net.cn&#x2F;plugin?id&#x3D;865)</span><br><span class="line">   2. 解压后将goods-nav目录放置在component目录下</span><br><span class="line">   3. 引入插件、注册、使用，与常规vue开发一模一样</span><br></pre></td></tr></table></figure>   <template>    <view>        <view class="goods-carts">            <uni-goods-nav :options="options" :button-group="buttonGroup" />        </view>    </view></template><script>    import uniGoodsNav from '@/components/uni-goods-nav/uni-goods-nav.vue'    export default {        components: { uniGoodsNav },        data() {            return {                options: [{                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/kefu.png',                    text: '客服'                }, {                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/dianpu.png',                    text: '店铺'                }, {                    icon: 'https://img-cdn-qiniu.dcloud.net.cn/uniapp/uni-ui/goodsnav/carts.png',                    text: '购物车',                    info: 2                }],                buttonGroup: [{                        text: '加入购物车',                        backgroundColor: '#ffa200 ',                        color: '#fff'                    },                    {                        text: '立即购买',                        backgroundColor: '#ff0000',                        color: '#fff'                    }                ]            }        }    }</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方式2： 与方式1一样，但使用组件时与小程序一样在pages.json中引入组件</span><br></pre></td></tr></table></figure>{    "path": "subPages/demo/uni-goods-nav",    "style": {            "navigationBarTitleText": "购物车",            "usingComponents": {            "uni-goods-nav": "/components/uni-goods-nav/uni-goods-nav"    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">得到的效果:  </span><br><span class="line">![购物车](&#x2F;images&#x2F;gwc.png)</span><br><span class="line">熟悉web开发的前端开发者都习惯从npm仓库中获取组件，所以很多时候觉得通过下载组件包然后解压的方式显得很怪异，实际上uni-app是支持npm方式引入组件的，只是这有很大风险会有部分平台不支持的问题。可以通过条件编译来屏蔽不支持的平台。以mpvue-echarts为例</span><br></pre></td></tr></table></figure>// npm安装包npm install echarts mpvue-echarts --save// echarts-weixin.vue<template>      <div class="container">          <mpvue-echarts :echarts="echarts" :onInit="onInit" />      </div>  </template>  <script>      import * as echarts from 'echarts'      import mpvueEcharts from 'mpvue-echarts'      export default {         components: {  mpvueEcharts  },          data() {              return {                  echarts,                  onInit: function (canvas, width, height) {                ...                }            }          }    }  </script>// echarts-h5.vue<script>import * as echarts from 'echarts'var myChart = echarts.init(document.getElementById('echarts'));myChart.setOption({    ...})</script>// pages.json#ifdef MP-WEIXIN{    "path": "pages/demo/echarts-weixin",    "style": {        "navigationBarTitleText": "demo-echarts"    }},#endif#ifdef H5{    "path": "pages/demo/echarts-h5",    "style": {        "navigationBarTitleText": "demo-echarts"    }},#endif<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3. 微信小程序组件</span><br><span class="line">由于性能问题，开发中应尽量避免直接使用小程序的组件。但是uni-app仍然 支持在App 和 小程序 中使用小程序自定义组件。  </span><br><span class="line">   1. 在项目src目录下新建小程序组件放置目录，微信及QQ-wxcomponents&#x2F;支付宝-mycomponents&#x2F;百度-swancomponents&#x2F;头条-ttcomponents</span><br><span class="line">   2. 在 pages.json 对应页面的 style -&gt; usingComponents 引入组件</span><br><span class="line">   3. 页面中使用组件</span><br><span class="line"></span><br><span class="line">以有赞的vant-weapp button组件为例</span><br><span class="line">1. 下载组件并放置到wxcomponents目录下:  </span><br><span class="line">    &#96;npm i @vant&#x2F;weapp -S --production&#96; </span><br><span class="line">    复制node_modules&#x2F;@vant&#x2F;weapp&#x2F;dist&#x2F;button到wxcomponents&#x2F;vant&#x2F;下</span><br><span class="line">2. pages.json 中使用组件</span><br></pre></td></tr></table></figure>{  "usingComponents": {    "van-button": "/wxcomponents/vant/button/index"  },  "navigationBarTitleText": "test-vant"}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. demo-test-wx.vue</span><br></pre></td></tr></table></figure><template>    <view>        <view class="uni-common-mt" style="text-align: center;">            <van-button type="primary" @click="onClick">vant按钮组件</van-button>        </view>    </view></template><script>    export default {        data() {            return {                checked: true            };        },        methods: {            onClick() {                uni.showToast({                    title: "uni-app支持在微信小程序、QQ小程序端、App端、H5端引入微信小程序自定义组件。",                    mask: false,                    icon: "none",                    duration: 3000                });            }        }    }</script><style></style>```效果：![结果](/images/test-vant.png)]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app基础学习笔记</title>
      <link href="/posts/55711/"/>
      <url>/posts/55711/</url>
      
        <content type="html"><![CDATA[<h2 id="uni-app基础学习笔记"><a href="#uni-app基础学习笔记" class="headerlink" title="uni-app基础学习笔记"></a>uni-app基础学习笔记</h2><h4 id="1-uni-app介绍"><a href="#1-uni-app介绍" class="headerlink" title="1. uni-app介绍"></a>1. uni-app介绍</h4><p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，一套代码可编译到iOS、Android、H5、小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台（可以通过条件编译区分各平台特殊代码）。uni-app完整支持vue生命周期和模板语法，如果会vue基本上就可以解决大多数问题了，学习成本非常低。(暂时绕开了原生APP开发相关如nvue，h5+等内容)<br><img src="/images/uni0124.png" alt="uni-app功能框架图"><br>官方演示用例(<a href="https://github.com/dcloudio/hello-uniapp" target="_blank" rel="noopener">https://github.com/dcloudio/hello-uniapp</a> )可快速体验和学习框架的常用组件和案例<br><img src="/images/demoQrCode.png" alt="通用快码"></p><h4 id="2-uni-app编码统一规范"><a href="#2-uni-app编码统一规范" class="headerlink" title="2. uni-app编码统一规范"></a>2. uni-app编码统一规范</h4><ul><li>页面组件遵循Vue 单文件组件 (SFC) 规范  </li><li>组件标签靠近微信小程序规范  </li><li>接口能力（JS API）靠近微信小程序规范  </li><li>数据绑定及事件处理靠近 Vue.js 规范，同时补充了App及页面的生命周期  </li><li>为兼容多端运行，建议使用flex布局进行开发  </li></ul><h4 id="3-创建uni-app项目注意事项"><a href="#3-创建uni-app项目注意事项" class="headerlink" title="3. 创建uni-app项目注意事项"></a>3. 创建uni-app项目注意事项</h4><ul><li>可通过HBuilderX可视化界面、vue-cli命令行两种方式快速创建项目。  </li><li>官方推出的 HBuilderX 编辑器，内置相关环境，开箱即用  </li><li>uni-app在发布到H5时支持所有vue的语法  </li><li>cli版如果想安装less、scss、ts等编译器，需自己手动npm安装。在HBuilderX的插件管理界面安装无效，那个只作用于HBuilderX创建的项目。  </li><li>HBuilderX云打包可以使用Dcloud公用开发者证书进行测试，或者使用自己的开发者证书。  </li></ul><h4 id="4-项目迁移注意事项"><a href="#4-项目迁移注意事项" class="headerlink" title="4. 项目迁移注意事项"></a>4. 项目迁移注意事项</h4><h6 id="1-H5项目迁移至uni-app"><a href="#1-H5项目迁移至uni-app" class="headerlink" title="(1)  H5项目迁移至uni-app"></a>(1)  H5项目迁移至uni-app</h6><ul><li>后缀名是.html，需要改为.vue，并注意遵循vue单文件组件SFC规范</li><li>uni-app默认是小程序的路由方式(pages.json管理页面)，如果使用vue-rooter的话可以使    用uni-simple-router等第三方插件做兼容</li><li>静态文件挪到static目录（静态资源只能存放于此）</li><li>使用scroll-view、swiper等原生组件替换H5组件</li><li>audio组件使用uni.getBackgroundAudioManager()替换</li><li>v-html使用rich-text组件或uparse扩展插件替换</li><li>uni-app非H5端不支持window、navigator、document等web专用对象，使用条件编译区       分</li><li>不支持 *选择器及部分新的css  </li></ul><h6 id="2-微信小程序转换uni-app指南及转换器：https-ask-dcloud-net-cn-article-35786"><a href="#2-微信小程序转换uni-app指南及转换器：https-ask-dcloud-net-cn-article-35786" class="headerlink" title="(2) 微信小程序转换uni-app指南及转换器：https://ask.dcloud.net.cn/article/35786"></a>(2) 微信小程序转换uni-app指南及转换器：<a href="https://ask.dcloud.net.cn/article/35786" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35786</a></h6><h4 id="5-关于uni-app生命周期"><a href="#5-关于uni-app生命周期" class="headerlink" title="5. 关于uni-app生命周期"></a>5. 关于uni-app生命周期</h4><p>uni-app 完整支持 Vue 实例的生命周期，此外新增应用生命周期及页面生命周期。</p><table><tr><th colspan="2" style="text-align:left;">应用生命周期</th></tr><tr><td>onLaunch</td><td>初始化完成时触发（全局只触发一次）</td></tr><tr><td>onShow</td><td>启动或从后台进入前台显示时触发</td></tr><tr><td>onHide</td><td>从前台进入后台时触发</td></tr><tr><td>onError</td><td>报错时触发</td></tr><tr><td>onUniNViewMessage</td><td>监听nvue页面发送的数据</td></tr></table>注:应用生命周期仅可在App.vue中监听，在其它页面监听无效。在onlaunch生命周期内进行页面的跳转可能会和pages.json内配置的第一个页面跳转冲突,造成白屏，需要进行延时跳转。<table style="text-align:left;"><tr><th colspan="2">页面生命周期（部分常用）</th></tr><tr><td>onLoad</td><td>监听页面加载，参数类型为Object，类似微信小程序</td></tr><tr><td>onShow</td><td>监听页面显示，包括从下级页面返回当前页面</td></tr><tr><td>onReady</td><td>监听页面初次渲染完成，如果渲染速度快，会在页面进入动画完成前触发</td></tr><tr><td>onPullDownRefresh</td><td>监听用户下拉动作，一般用于下拉刷新</td></tr><tr><td>onReachBottom</td><td>页面上拉触底事件的处理函数</td></tr><tr><td>onShareAppMessage</td><td>用户点击右上角分享(小程序)</td></tr><tr><td>onBackPress</td><td>监听页面返回(https://ask.dcloud.net.cn/article/35120)</td></tr></table>关于.nvue页面(即Native vue)：uni-app App端内置 weex 渲染引擎，提供了原生渲染能力，但是weex提供的api不完整,nuve相当于给weex补充了大量组件和api，以及丰富的Plus API、Native.js、原生插件。(详情: https://ask.dcloud.net.cn/article/36074)<h4 id="6-关于uni-app组件注意事项"><a href="#6-关于uni-app组件注意事项" class="headerlink" title="6. 关于uni-app组件注意事项"></a>6. 关于uni-app组件注意事项</h4><ul><li>非H5端需要注意Slot不支持scoped，不支持动态组件、异步组件、inline-template、X-Templates、keep-alive、transition</li><li>uni-app 内置了小程序的所有组件，但原生组件上的事件绑定需要以vue语法来写(bindchange=”xxx”等改成@change=”xxx”)</li><li>uni-app组件有命名限制，组件名最好有特殊前缀或后缀(参考: <a href="https://uniapp.dcloud.io/use?id=%e5%91%bd%e5%90%8d%e9%99%90%e5%88%b6" target="_blank" rel="noopener">https://uniapp.dcloud.io/use?id=%e5%91%bd%e5%90%8d%e9%99%90%e5%88%b6</a> )</li><li>uni-app内置了vuex</li><li>uni-app支持小程序自定义组件(wxcomponents目录下)，但是小程序组件的性能不如vue组件，不建议使用,另外小程序自定义组件只能在pages.json中配置 usingComponents,不支持页面引用。(参考:  <a href="https://ask.dcloud.net.cn/article/35786" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35786</a> )</li></ul><h4 id="7-条件编译"><a href="#7-条件编译" class="headerlink" title="7. 条件编译"></a>7. 条件编译</h4><ul><li>用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。uni-app支持ifdef和ifndef(除了xx平台)，多个平台用||连接。例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef H5||APP-PLUS</span><br><span class="line">需条件编译的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li>如果想把各平台的页面文件更彻底的分开，也可以在uni-app项目根目录创建platforms目录，然后在下面创建APP-PLUS、MP-WEIXIN等子目录，存放不同平台的文件。</li><li>静态资源按不同平台区分的可在static目录下新建平台目录(注意使用小写，如：mp-weixin等)</li></ul><h4 id="8-部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法）"><a href="#8-部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法）" class="headerlink" title="8. 部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法）"></a>8. 部分常见问题及解决方案（参考官方文档避免官方已指出的不支持写法）</h4><ul><li>各家小程序的浏览器内核不同，会造成css兼容性问题(参考：<a href="https://ask.dcloud.net.cn/article/1318" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/1318</a> )</li><li>各家小程序存在不一样的支持度(如：支付宝小程序不支持ECharts，百度小程序不支持v-if和for同时使用)，遇到相关问题可关注是否有相应版本更新或使用条件编译来不同平台不同处理。</li><li>微信小程序端的原生组件存在层级问题，可以用cover-view、cover-image来进行覆盖</li><li>uni-app中可以使用upx作为自适应单位，但不支持动态绑定，可以使用uni.upx2px转化为px。</li><li>关于Class 与 Style 绑定，非H5端支持简单的样式绑定，绑定的值只能是字符串，不支持复杂的绑定，比如:class=”[class-a,class-b]”</li></ul><h4 id="9-使用总结"><a href="#9-使用总结" class="headerlink" title="9. 使用总结"></a>9. 使用总结</h4><ul><li>uni-app官方文档( <a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">https://uniapp.dcloud.io/README</a> )非常详细，对于初学和使用uni-app非常有帮助</li><li>因基本完整支持vue的语法及特性,uni-app的学习成本很低</li><li>对于跨端uni-app最好是以小程序的编码方式为主向其他端扩展，参考以上第3条H5项目迁移至uni-app</li><li>开发工具官方推荐HBuilderX，对于惯用Sublime/Atom等编辑器的开发者可以平滑过渡，其他开发者使用vue-cli的方式也很方便，但是仍然需要HbuilderX打包到安卓/IOS(无需打包原生APP的忽略)</li><li>目前uni-app插件市场( <a href="https://ext.dcloud.net.cn/" target="_blank" rel="noopener">https://ext.dcloud.net.cn/</a> )有1K+第三方插件，但是质量良莠不齐只能筛选后使用和参考</li><li>uni-app支持使用npm安装第三方包，但是为多端兼容考虑应优先从uni-app插件市场获取插件，直接从npm下载库很容易只兼容H5端，当然也可使用条件编译将该部分特殊处理</li></ul><p>总体来说uni-app是一个非常好的跨平台开发框架，框架本身的文档也非常详细，但是目前开放生态并不是很完善，很多第三方插件文档也很模糊，如果单纯只开发某一个平台的代码可以绕开uni-app，但是如果是跨端需求则非常适合用uni-app，因为使用条件编译进行各平台的独有代码开发也没有增加工作量。uni-app在跨端抹平度、扩展灵活性、性能体验、学习成本、开发成本等方面都非常优秀(官方说的8个指标虽有广告成分但也确实很优秀)。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
